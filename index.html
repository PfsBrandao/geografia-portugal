<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geografia PT — Jogo</title>
  <link rel="icon" href="data:,">

  <!-- PWA -->
  <link rel="manifest" href="/geografia-portugal/manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">

  <!-- iOS / Mobile (Add to Home Screen) -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="apple-touch-icon" href="/geografia-portugal/icons/icon-192.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 0; background:#fff; }
    .screen { display: none; height: 100vh; }
    .screen.active { display: block; }

    .menuWrap {
      min-height: 100dvh;
      background: #e8e9ea;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing: border-box;
    }
    .menuPhone {
      width: min(420px, 94vw);
      background: #0b0b0f;
      border-radius: 22px;
      padding: 16px;
      box-sizing: border-box;
      border: 2px solid rgba(0,0,0,.12);
    }
    .menuLogo {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      background: #000;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      margin-bottom: 14px;
      position: relative;
    }
    .menuLogo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display:block;
    }
    .menuLogo .menuTitleOverlay{
      position:absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.55);
      color:#fff;
      font-weight: 900;
      font-size: 18px;
      text-align: center;
      display:none;
    }
    .menuLogo.hasTitle .menuTitleOverlay{ display:block; }

    .menuBtns { display:flex; flex-direction:column; gap: 12px; }
    .menuBtn {
      width: 100%;
      min-height: 64px;
      border-radius: 16px;
      border: 2px solid rgba(255,255,255,.15);
      background: #b1b2b5;
      font-size: 28px;
      font-weight: 900;
      cursor: pointer;
      user-select:none;
    }
    .menuBtn:active { transform: translateY(1px); }
    .menuBtn.disabled { opacity: .55; cursor: not-allowed; }
    .menuBtn.small { font-size: 26px; }

    :root {
      --bg: #0b0b0f;
      --panel: #efefef;
      --panelBorder: #bdbdbd;
    }

    html, body { height: 100%; }

    body.playing {
      background: var(--bg);
      height: 100dvh;
      overflow: hidden;
    }

    /* =========================
       GAME SHELL (ROBUST MOBILE GRID)
       ========================= */
    .gameShell {
      height: 100dvh;
      display: grid;
      gap: 6px;

      padding: 10px;
      padding-top: calc(10px + env(safe-area-inset-top));
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      box-sizing: border-box;

      grid-template-rows:
        40px
        minmax(0, 0.80fr)
        64px
        minmax(0, 1.20fr);
    }

    .gameTop { display:flex; align-items:center; justify-content:flex-start; }
    .exitBtn{
      width: 44px;
      height: 34px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color:#fff;
      font-weight: 900;
      user-select:none;
      cursor:pointer;
    }

    .gameHUD {
      display: grid;
      grid-template-columns: 1fr 1fr 1.2fr;
      gap: 6px;
      align-items: stretch;
    }
    .hudBox {
      background: var(--panel);
      border: 2px solid var(--panelBorder);
      border-radius: 14px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      line-height: 1.05;
      padding: 6px;
      box-sizing: border-box;
      user-select: none;
    }
    .hudBox .k { font-size: 12px; color: #222; opacity: .75; }
    .hudBox .v { font-size: 22px; font-weight: 900; color: #111; }

    .hudBtn {
      border-radius: 14px;
      border: 2px solid #cfcfcf;
      font-size: 18px;
      font-weight: 900;
      cursor: pointer;
      background: linear-gradient(#33b5ff, #0c79d6);
      color: #071018;
      user-select: none;
    }
    .hudBtn:disabled { opacity: .6; cursor: not-allowed; }

    .gameStage {
      background: #eaeaea;
      border-radius: 18px;
      border: 3px solid var(--panelBorder);
      overflow: hidden;
      position: relative;
      min-height: 200px;
      min-width: 0;
    }
    #map { height: 100%; width: 100%; background: #fff; }

    body.playing #map {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    body.playing .leaflet-control-zoom,
    body.playing .leaflet-control-attribution { display: none !important; }

    /* ==============
       INSET (AÇORES)
       ============== */
    .insetWrap{
      position:absolute;
      left: 10px;
      bottom: 10px;
      width: min(29vw, 154px);
      height: min(29vw, 154px);
      border-radius: 14px;
      border: 3px solid rgba(255,255,255,.85);
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      overflow:hidden;
      background:#fff;
      z-index: 40;
      display:none;
    }
    .insetWrap.show{ display:block; }
    #insetMap{ width:100%; height:100%; background:#fff; }
    body.playing #insetMap {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* =========================
       GAME BOTTOM
       A) question bar
       B) lvl4 bar (auto)
       C) choicesBlock (scroll + shrink)
       D) keyboard (auto)
       ========================= */
    .gameBottom {
      background: rgba(16,16,24,.95);
      border-radius: 18px;
      padding: 8px;
      box-sizing: border-box;
      color: #f2f2f2;

      display: grid;
      grid-template-rows: auto minmax(0, 1fr) auto;
      gap: 8px;

      overflow: hidden;
      min-height: 0;
      min-width: 0;
    }

    #choicesBlock{
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    #choicesBlock::after{
      content:"";
      display:block;
      height: 6px;
    }

    .choices {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      margin-top: 6px;
    }
    .choiceBtn {
      min-height: 44px;
      border-radius: 16px;
      border: 2px solid #cfcfcf;
      font-size: 14px;
      font-weight: 900;
      background: linear-gradient(#33b5ff, #0c79d6);
      color: #071018;
      white-space: normal;
      line-height: 1.08;
      cursor:pointer;
      user-select:none;
      padding: 10px 8px;
      -webkit-tap-highlight-color: transparent;
    }
    .choiceBtn:active { transform: translateY(1px); }
    .choiceBtn:disabled { opacity: 0.65; cursor: not-allowed; }
    .choiceBtn.hidden { visibility: hidden; }

    .choiceBtn.correct {
      background: #17c964 !important;
      border-color: rgba(0,0,0,.18) !important;
      color: #071018 !important;
    }
    .choiceBtn.wrong {
      background: #ff4d4f !important;
      border-color: rgba(0,0,0,.18) !important;
      color: #071018 !important;
    }

    .choiceBtn.ghost { display: none; }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.58);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing:border-box;
      z-index: 50;
    }
    .overlay.show { display:flex; }
    .overlayCard {
      width: min(420px, 92vw);
      background: #efefef;
      border: 2px solid #bdbdbd;
      border-radius: 18px;
      padding: 16px;
      box-sizing:border-box;
      text-align:center;
    }
    .overlayCard .t { font-size: 24px; font-weight: 900; color: #111; margin: 0 0 10px; }
    .overlayCard .p { font-size: 18px; font-weight: 800; color: #111; margin: 8px 0; }
    .overlayCard .s { font-size: 13px; color: #333; margin-top: 10px; opacity: .85; }

    /* =========================
       NÍVEL 4: BARRA + TECLADO (ROBUST)
       ========================= */
    .lvl4Bar{
      background:#efefef;
      border:2px solid #cfcfcf;
      border-radius: 14px;
      padding: 8px 10px;
      color:#111;
      font-weight: 900;
      text-align:center;
      user-select:none;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .kbWrap{
      --kbKeyH: clamp(28px, 5.2dvh, 38px);
      --kbGap: 6px;

      background: rgba(255,255,255,.10);
      border: 2px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 6px;
      display:flex;
      flex-direction: column;
      gap: var(--kbGap);
      user-select:none;
      -webkit-tap-highlight-color: transparent;

      flex: 0 0 auto;
      min-width: 0;
    }
    .kbWrap.disabled{
      opacity: .75;
      pointer-events: none;
    }
    .kbRow{
      display:flex;
      gap: var(--kbGap);
      justify-content: center;
    }
    .kbKey{
      flex: 0 0 auto;
      min-width: 26px;
      height: var(--kbKeyH);
      padding: 0 8px;
      border-radius: 10px;
      border: 2px solid rgba(0,0,0,.18);
      background: #e9e9e9;
      color:#111;
      font-weight: 900;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 0 rgba(0,0,0,.12);
    }
    .kbKey:active{ transform: translateY(1px); box-shadow: 0 1px 0 rgba(0,0,0,.12); }
    .kbKey.wide{ min-width: 64px; }
    .kbKey.space{ min-width: min(52vw, 280px); }
    .kbKey.confirm{ min-width: 78px; }

    /* =========================
       OPTIONS TABLE SCREENS (v2: por categoria)
       ========================= */
    .optWrap {
      min-height: 100dvh;
      background: #e8e9ea;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing: border-box;
    }
    .optPhone {
      width: min(560px, 94vw);
      background: #ffffff;
      border-radius: 22px;
      padding: 14px;
      box-sizing: border-box;
      border: 2px solid rgba(0,0,0,.12);
    }
    .optHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 6px 4px 10px;
      box-sizing:border-box;
    }
    .optTitle {
      font-weight: 900;
      font-size: 18px;
      color:#111;
    }
    .optMeta {
      font-size: 12px;
      color:#444;
    }
    .optHint {
      font-size: 12px;
      color:#444;
      margin: 0 4px 10px;
      line-height: 1.35;
    }

    .optPack{
      border: 1px solid #d6d6d6;
      border-radius: 14px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    .optPackHead{
      background:#f3f3f3;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      box-sizing:border-box;
      font-weight: 900;
      color:#111;
    }
    .optPackHead .sub{ font-weight: 800; font-size: 11px; color:#444; opacity:.9; }

    .optCatHead{
      display:grid;
      grid-template-columns: 1fr repeat(4, 34px);
      gap: 0;
      border-top: 1px solid #e7e7e7;
      background:#fafafa;
      font-weight: 900;
      font-size: 12px;
      color:#111;
      min-height: 42px;
    }
    .optCatHead .c{
      display:flex; align-items:center; justify-content:center;
      border-right: 1px solid #e7e7e7;
    }
    .optCatHead .c:first-child{ justify-content:flex-start; padding-left: 12px; }
    .optCatHead .c:last-child{ border-right:none; }

    .optCatRow{
      display:grid;
      grid-template-columns: 1fr repeat(4, 34px);
      gap: 0;
      border-top: 1px solid #eeeeee;
      min-height: 46px;
      align-items: stretch;
    }
    .optCatRow .c{
      display:flex; align-items:center;
      padding: 8px 12px;
      box-sizing:border-box;
      border-right: 1px solid #eeeeee;
      font-size: 12px;
      color:#111;
      font-weight: 800;
      line-height: 1.1;
    }
    .optCatRow .c.dotCell{ justify-content:center; padding: 8px; }
    .optCatRow .c:last-child{ border-right:none; }

    .dot {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid #999;
      background: #f6f6f6;
      cursor: pointer;
      display:inline-block;
      position: relative;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .dot.on {
      border-color: #2e7d32;
      background: #2ee66a;
      box-shadow: 0 0 0 2px rgba(46, 125, 50, 0.15);
    }

    .optFooter {
      display:flex;
      gap: 10px;
      justify-content:center;
      margin-top: 12px;
    }
    .optBtn {
      min-height: 52px;
      padding: 10px 14px;
      border-radius: 16px;
      border: 2px solid #cfcfcf;
      background: #b1b2b5;
      font-weight: 900;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
    }
    .optBtn.primary {
      background: linear-gradient(#33b5ff, #0c79d6);
      border-color: #cfcfcf;
      color:#071018;
    }

    @media (max-width: 420px) {
      .hudBox .v { font-size: 18px; }
      .hudBtn { font-size: 16px; }
      .choiceBtn { min-height: 42px; font-size: 13px; }
      .optPhone { padding: 12px; }

      .dot { width: 16px; height: 16px; }

      .insetWrap{
        width: min(34vw, 160px);
        height: min(34vw, 160px);
      }

      .kbWrap{ --kbKeyH: clamp(26px, 4.8dvh, 34px); --kbGap: 5px; padding: 5px; }
      .kbKey{ font-size: 13px; min-width: 24px; padding: 0 7px; }
      .kbKey.wide{ min-width: 58px; }
      .kbKey.space{ min-width: min(56vw, 260px); }
      .kbKey.confirm{ min-width: 70px; }

      .optCatHead, .optCatRow{ grid-template-columns: 1fr repeat(4, 30px); }
    }

    @media (max-height: 700px) {
      .gameShell { gap: 5px; padding: 8px; padding-top: calc(8px + env(safe-area-inset-top)); padding-bottom: calc(8px + env(safe-area-inset-bottom)); }
      .kbWrap { padding: 5px; --kbGap: 5px; }
      .kbKey { font-size: 13px; }
      .gameStage { min-height: 180px; }
    }

    @media (min-width: 900px) {
      .gameShell { max-width: 1100px; margin: 0 auto; }
    }
  
    /* =========================
       STAGE TEXT MODE (DEMOGRAFIA)
       ========================= */
    .gameStage.textMode #map{
      opacity: 0;
      pointer-events: none;
      user-select: none;
    }
    .gameStage.textMode .insetWrap{ display:none !important; }
    .stageText{
      position:absolute;
      inset: 0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 16px;
      box-sizing:border-box;
      z-index: 30;
    }
    .stageMunicipio{
      font-size: 32px;
      font-weight: 900;
      color:#111;
      margin-bottom: 8px;
    }
    .stageTipo{
      font-size: 18px;
      font-weight: 900;
      color:#111;
      opacity: .85;
    }

    /* teclado numérico maior */
    .kbWrap.num{
      --kbKeyH: clamp(44px, 7.2dvh, 62px);
      --kbGap: 8px;
      padding: 10px;
    }
    .kbWrap.num .kbKey{
      font-size: 18px;
      border-radius: 12px;
      min-width: 34px;
    }

  </style>
</head>

<body>
  <!-- MENU -->
  <div id="screenMenu" class="screen active">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo" aria-label="Geo-PT">
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
        </div>
        <div class="menuBtns">
          <button id="btnMenuPlay" class="menuBtn">Jogar</button>
          <button class="menuBtn disabled" disabled>Estudar</button>
          <button class="menuBtn disabled" disabled>Perfil</button>
          <button id="btnMenuOptions" class="menuBtn">Opções</button>
          <button id="btnMenuExit" class="menuBtn small">Sair</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SESSION LENGTH MENU -->
  <div id="screenSessionLen" class="screen">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo hasTitle" aria-label="Geo-PT">
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
          <div class="menuTitleOverlay">Quantas perguntas?</div>
        </div>
        <div class="menuBtns">
          <button class="menuBtn" data-qlen="10">10</button>
          <button class="menuBtn" data-qlen="25">25</button>
          <button class="menuBtn" data-qlen="50">50</button>
          <button class="menuBtn" data-qlen="100">100</button>
          <button id="btnSessionLenBack" class="menuBtn small">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- OPTIONS: MENU COM CATEGORIAS -->
  <div id="screenOptionsMenu" class="screen">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo hasTitle" aria-label="Opções">
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
          <div class="menuTitleOverlay">Opções</div>
        </div>
        <div class="menuBtns">
          <button id="btnOptCatDistricts" class="menuBtn">Distritos</button>
          <button id="btnOptCatRivers" class="menuBtn disabled" disabled>Rios</button>
          <button id="btnOptCatRA" class="menuBtn">Regiões Autónomas</button>
          <button id="btnOptCatMountains" class="menuBtn disabled" disabled>Serras</button>
          <button id="btnOptCatFlags" class="menuBtn disabled" disabled>Bandeiras</button>
          <button id="btnOptMenuBack" class="menuBtn small">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- OPTIONS: DISTRITOS -->
  <div id="screenOptionsDistricts" class="screen">
    <div class="optWrap">
      <div class="optPhone">
        <div class="optHeader">
          <div>
            <div class="optTitle">Distritos</div>
            <div class="optMeta" id="optSelectedCountDistricts">Selecionados: 0</div>
          </div>
          <button id="btnOptBackTopDistricts" class="exitBtn" type="button" style="color:#111; border-color:#ddd; background:#f3f3f3;">⟵</button>
        </div>

        <div class="optHint">
          Define o que é perguntado em cada distrito (categorias independentes).
          Nível 1 = 4 opções, Nível 2 = 6 opções, Nível 3 = 8 opções.
          Nível 4 = escrever no teclado do jogo (nomes) ou valor numérico (±10%).
          (Bandeiras está previsto mas ainda não implementado.)
        </div>

        <div id="optDistrictsBlocks"></div>

        <div class="optFooter">
          <button id="btnOptResetDistricts" class="optBtn" type="button">Reset</button>
          <button id="btnOptSaveDistricts" class="optBtn primary" type="button">Guardar</button>
          <button id="btnOptBackDistricts" class="optBtn" type="button">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- OPTIONS: REGIÕES AUTÓNOMAS -->
  <div id="screenOptionsRA" class="screen">
    <div class="optWrap">
      <div class="optPhone">
        <div class="optHeader">
          <div>
            <div class="optTitle">Regiões Autónomas</div>
            <div class="optMeta" id="optSelectedCountRA">Selecionados: 0</div>
          </div>
          <button id="btnOptBackTopRA" class="exitBtn" type="button" style="color:#111; border-color:#ddd; background:#f3f3f3;">⟵</button>
        </div>

        <div class="optHint">
          Define o que é perguntado em cada região (categorias independentes).
          Nível 1 = 4 opções, Nível 2 = 6 opções, Nível 3 = 8 opções.
          Nível 4 = escrever no teclado do jogo (nomes) ou valor numérico (±10%).
        </div>

        <div id="optRABlocks"></div>

        <div class="optFooter">
          <button id="btnOptResetRA" class="optBtn" type="button">Reset</button>
          <button id="btnOptSaveRA" class="optBtn primary" type="button">Guardar</button>
          <button id="btnOptBackRA" class="optBtn" type="button">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="screenLoading" class="screen">
    <div class="menuWrap">
      <div class="menuPhone" style="background:#fff;">
        <div style="font-weight:900; font-size:20px; margin-bottom:10px;">A carregar…</div>
        <div id="loadingText" style="font-size:13px; color:#444;">—</div>
        <div style="margin-top:12px; height:10px; background:#eee; border-radius:999px; overflow:hidden; border:1px solid #e6e6e6;">
          <div id="loadingBar" style="height:100%; width:0%; background:#111; transition:width 150ms linear;"></div>
        </div>
        <div id="loadingPct" style="margin-top:10px; font-size:13px; color:#444;">0%</div>
      </div>
    </div>
  </div>

  <!-- GAME -->
  <div id="screenGame" class="screen">
    <div class="gameShell" id="gameShell">
      <div class="gameTop">
        <button id="btnExit" class="exitBtn" type="button">⟵</button>
      </div>

      <div class="gameStage">
        <div id="map"></div>

        <div id="stageText" class="stageText" aria-live="polite" style="display:none;">
          <div id="stageMunicipio" class="stageMunicipio">—</div>
          <div id="stageTipo" class="stageTipo">—</div>
        </div>


        <!-- INSET (AÇORES) -->
        <div id="insetWrap" class="insetWrap" aria-hidden="true">
          <div id="insetMap"></div>
        </div>

        <div id="finalOverlay" class="overlay" role="dialog" aria-modal="true">
          <div class="overlayCard">
            <div class="t">Fim!</div>
            <div class="p" id="finalCorrect">Corretas: 0/10</div>
            <div class="p" id="finalXP">XP ganho: 0</div>
            <div class="s">Toca para voltar ao menu</div>
          </div>
        </div>
      </div>

      <div class="gameHUD">
        <div class="hudBox">
          <div class="k">Tempo</div>
          <div class="v"><span id="timeLine">60</span></div>
        </div>

        <div class="hudBox">
          <div class="k">Questão</div>
          <div class="v"><span id="sessionLine">1/10</span></div>
        </div>

        <button class="hudBtn" id="btnHint" type="button">Ajuda</button>
      </div>

      <div class="gameBottom">

        <!-- NÍVEL 4 -->
        <div id="lvl4Bar" class="lvl4Bar" style="display:none;">
          <span id="lvl4Typed">—</span>
        </div>

        <div id="choicesBlock">
          <div class="choices" id="choices"></div>
        </div>

        <div id="lvl4Keyboard" class="kbWrap" style="display:none;" aria-label="Teclado">
          <div class="kbRow" data-row="1"></div>
          <div class="kbRow" data-row="2"></div>
          <div class="kbRow" data-row="3"></div>
          <div class="kbRow" data-row="4"></div>
          <div class="kbRow" data-row="5"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/geografia-portugal/sw.js").catch(() => {});
    }

    const BASE = "/geografia-portugal/";
    const FILES = {
      concelhosPT: (districtSlug) => `${BASE}data/concelhos_${districtSlug}.geojson`,
      concelhosAZ: `${BASE}data/concelhos_acores.geojson`,
      concelhosMD: `${BASE}data/concelhos_madeira.geojson`,
      demografia: `${BASE}data/municipios_demografia.json`,
    };

    const DISTRICTS_PT = [
      ["Aveiro","aveiro"], ["Beja","beja"], ["Braga","braga"], ["Bragança","braganca"],
      ["Castelo Branco","castelo_branco"], ["Coimbra","coimbra"], ["Évora","evora"],
      ["Faro","faro"], ["Guarda","guarda"], ["Leiria","leiria"], ["Lisboa","lisboa"],
      ["Portalegre","portalegre"], ["Porto","porto"], ["Santarém","santarem"],
      ["Setúbal","setubal"], ["Viana do Castelo","viana_do_castelo"],
      ["Vila Real","vila_real"], ["Viseu","viseu"]
    ];

    function getAllPacks() {
      const arr = DISTRICTS_PT.map(([name, slug]) => ({ id:`pt:${slug}`, label:`Distrito — ${name}`, region:"pt", slug, short:name }));
      arr.push({ id:"az", label:"Região — Açores", region:"az", slug:"acores", short:"Açores" });
      arr.push({ id:"md", label:"Região — Madeira", region:"md", slug:"madeira", short:"Madeira" });
      return arr;
    }

    const CATEGORIES = [
      { id:"identify", label:"Concelhos no mapa", kind:"name" },
      { id:"pop", label:"População (habitantes)", kind:"num", unit:"habitantes" },
      { id:"area", label:"Área (km²)", kind:"num", unit:"km²" },
      { id:"dens", label:"Densidade (hab/km²)", kind:"num", unit:"hab/km²" },
      { id:"flags", label:"(Futuro) Bandeiras", kind:"future" }
    ];

    const PLAY = {
      TIME_LIMIT_SEC: 60,
      optionsByLevel: (lvl) => (lvl === 1 ? 4 : lvl === 2 ? 6 : 8),
      difficultyMultByLevel: (lvl) => (lvl === 1 ? 1.00 : lvl === 2 ? 1.18 : 1.38),
      hintMult: 0.60,
    };

    let QUESTIONS_PER_SESSION = 10;

    function normalize(s) {
      return (s || "").trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
    function pickProp(props, keys) {
      for (const k of keys) {
        if (props && props[k] != null && String(props[k]).trim() !== "") return String(props[k]);
      }
      return "";
    }
    function getMunicipalityName(props) {
      return pickProp(props, ["Concelho","CONCELHO","MUNICIPIO","Municipio","MUNICÍPIO","municipio","NAME_2","NAME2","NAME"]);
    }
    function getIslandName(props) {
      return pickProp(props, ["ILHA","Ilha","ilha","ILHA_1","Ilha_1","ISLAND","Island","island"]);
    }
    function getMunicipalityKey(props) {
      const code = pickProp(props, [
        "DICOFRE","dicofre",
        "CODIGO","codigo",
        "COD_MUN","cod_mun",
        "ID","id",
        "OBJECTID","objectid"
      ]);
      if (code) return `id:${normalize(code)}`;
      const name = getMunicipalityName(props);
      return `nm:${normalize(name)}`;
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function sampleDistinct(arr, n, forbidSet) {
      const pool = [];
      for (const x of arr) {
        if (forbidSet && forbidSet.has(x)) continue;
        pool.push(x);
      }
      const s = shuffle(pool);
      return s.slice(0, Math.min(n, s.length));
    }

    function assertGeoJSONLooksLikeLonLat(fc, sampleN = 3) {
      const coords = [];
      function walkGeom(g) {
        if (!g) return;
        const t = g.type;
        const c = g.coordinates;
        if (!t || !c) return;
        if (t === "Point") coords.push(c);
        else if (t === "MultiPoint" || t === "LineString") c.forEach(p => coords.push(p));
        else if (t === "MultiLineString") c.flat().forEach(p => coords.push(p));
        else if (t === "Polygon") c.flat().forEach(p => coords.push(p));
        else if (t === "MultiPolygon") c.flat(2).forEach(p => coords.push(p));
        else if (t === "GeometryCollection" && Array.isArray(g.geometries)) g.geometries.forEach(walkGeom);
      }
      for (const f of (fc.features || [])) {
        walkGeom(f.geometry);
        if (coords.length >= sampleN) break;
      }
      if (coords.length === 0) return { ok: false, reason: "GeoJSON sem coordenadas." };
      const [lon, lat] = coords[0] || [];
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) return { ok: false, reason: "Coordenadas inválidas (NaN/null)." };
      const inLonLatRange = (Math.abs(lon) <= 180 && Math.abs(lat) <= 90);
      if (!inLonLatRange) return { ok: false, reason: `CRS errado? Ex: [${lon}, ${lat}]` };
      return { ok: true, reason: "ok" };
    }

    function safeZoomToBounds(m, b, fitOpts = {}, padDeg = 0.25) {
      if (!m || !b || !b.isValid || !b.isValid()) return null;
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();
      const dLat = Math.abs(ne.lat - sw.lat);
      const dLng = Math.abs(ne.lng - sw.lng);

      if (dLat < 0.01 && dLng < 0.01) {
        const c = b.getCenter();
        const expanded = L.latLngBounds(
          [c.lat - padDeg, c.lng - padDeg],
          [c.lat + padDeg, c.lng + padDeg]
        );
        m.fitBounds(expanded, fitOpts);
        return expanded;
      }
      m.fitBounds(b, fitOpts);
      return b;
    }

    function toNum(x) {
      if (typeof x === "number") return x;
      if (typeof x !== "string") return Number(x);
      const s = x.trim().replace(",", ".");
      return Number(s);
    }
    function coordPairOk(pair) {
      if (!Array.isArray(pair) || pair.length < 2) return false;
      const lon = toNum(pair[0]);
      const lat = toNum(pair[1]);
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) return false;
      if (Math.abs(lon) > 180 || Math.abs(lat) > 90) return false;
      return true;
    }
    function geometryHasOnlyValidCoords(geom) {
      if (!geom) return false;
      const t = geom.type;
      const c = geom.coordinates;
      if (t === "Point") return coordPairOk(c);
      if (t === "MultiPoint" || t === "LineString") return Array.isArray(c) && c.every(coordPairOk);
      if (t === "MultiLineString" || t === "Polygon") return Array.isArray(c) && c.every(line => Array.isArray(line) && line.every(coordPairOk));
      if (t === "MultiPolygon") return Array.isArray(c) && c.every(poly => Array.isArray(poly) && poly.every(ring => Array.isArray(ring) && ring.every(coordPairOk)));
      if (t === "GeometryCollection") return Array.isArray(geom.geometries) && geom.geometries.every(geometryHasOnlyValidCoords);
      return false;
    }
    function sanitizeFeatureCollection(fc) {
      const features = Array.isArray(fc?.features) ? fc.features : [];
      const kept = [];
      const dropped = [];
      for (const f of features) {
        const props = f?.properties || {};
        const name = getMunicipalityName(props) || "(sem nome)";
        if (geometryHasOnlyValidCoords(f?.geometry)) kept.push(f);
        else dropped.push(name);
      }
      if (dropped.length) console.warn("Concelhos removidos por coordenadas estranhas:", dropped);
      return { cleaned: { ...fc, features: kept }, dropped };
    }

    const cache = new Map();
    async function loadJSON(url) {
      if (cache.has(url)) return cache.get(url);
      const p = fetch(url)
        .then(async (r) => {
          if (!r.ok) throw new Error(`Falha a carregar ${url} (HTTP ${r.status})`);
          const txt = await r.text();
          const clean = (txt.charCodeAt(0) === 0xFEFF) ? txt.slice(1) : txt;
          return JSON.parse(clean);
        })
        .catch((err) => {
          cache.delete(url);
          throw err;
        });
      cache.set(url, p);
      return p;
    }

    // SCREENS
    const screenMenu = document.getElementById("screenMenu");
    const screenSessionLen = document.getElementById("screenSessionLen");
    const screenOptionsMenu = document.getElementById("screenOptionsMenu");
    const screenOptionsDistricts = document.getElementById("screenOptionsDistricts");
    const screenOptionsRA = document.getElementById("screenOptionsRA");
    const screenLoading = document.getElementById("screenLoading");
    const screenGame = document.getElementById("screenGame");

    const loadingText = document.getElementById("loadingText");
    const loadingBar = document.getElementById("loadingBar");
    const loadingPct = document.getElementById("loadingPct");

    function showScreen(el) {
      const all = [screenMenu, screenSessionLen, screenOptionsMenu, screenOptionsDistricts, screenOptionsRA, screenLoading, screenGame];
      for (const s of all) s.classList.remove("active");
      el.classList.add("active");
    }
    function setLoading(step, pct) {
      loadingText.textContent = step;
      loadingBar.style.width = `${pct}%`;
      loadingPct.textContent = `${pct}%`;
    }

    // MENU BUTTONS
    const btnMenuPlay = document.getElementById("btnMenuPlay");
    const btnMenuOptions = document.getElementById("btnMenuOptions");
    const btnMenuExit = document.getElementById("btnMenuExit");

    btnMenuExit.addEventListener("click", () => {
      try { window.close(); } catch {}
      alert("Para sair, fecha o separador / a app (PWA).");
    });

    btnMenuPlay.addEventListener("click", () => showScreen(screenSessionLen));
    document.getElementById("btnSessionLenBack").addEventListener("click", () => showScreen(screenMenu));

    screenSessionLen.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-qlen]");
      if (!btn) return;
      const n = Number(btn.dataset.qlen || 10);
      QUESTIONS_PER_SESSION = ([10,25,50,100].includes(n) ? n : 10);
      startGame();
    });

    // OPTIONS MENU OPEN/CLOSE
    btnMenuOptions.addEventListener("click", () => showScreen(screenOptionsMenu));
    document.getElementById("btnOptMenuBack").addEventListener("click", () => showScreen(screenMenu));

    // OPTIONS CATEGORY BUTTONS
    document.getElementById("btnOptCatDistricts").addEventListener("click", () => openOptionsDistricts());
    document.getElementById("btnOptCatRA").addEventListener("click", () => openOptionsRA());

    // GAME UI
    const btnExit = document.getElementById("btnExit");
    const timeLine = document.getElementById("timeLine");
    const sessionLine = document.getElementById("sessionLine");
    const btnHint = document.getElementById("btnHint");
    const choicesEl = document.getElementById("choices");
    const finalOverlay = document.getElementById("finalOverlay");
    const finalCorrect = document.getElementById("finalCorrect");
    const finalXP = document.getElementById("finalXP");
    const insetWrap = document.getElementById("insetWrap");

    const gameStageEl = document.querySelector(".gameStage");
    const stageText = document.getElementById("stageText");
    const stageMunicipio = document.getElementById("stageMunicipio");
    const stageTipo = document.getElementById("stageTipo");

    // NÍVEL 4 UI
    const lvl4Bar = document.getElementById("lvl4Bar");
    const lvl4TypedEl = document.getElementById("lvl4Typed");
    const lvl4Keyboard = document.getElementById("lvl4Keyboard");

    /* =========================
       OPTIONS STATE (v2)
       ========================= */
    const OPT_KEY = "geoPT_options_v2";

    function makeEmptyCfg() {
      const obj = {};
      for (const c of CATEGORIES) {
        if (c.id === "flags") continue; // previsto, mas não joga
        obj[c.id] = 0;
      }
      return obj;
    }

    function defaultOptions() {
      // default: Porto com identificação no nível 3
      return { cfg: { "pt:porto": { ...makeEmptyCfg(), identify: 3 } } };
    }

    function migrateV1ToV2(o) {
      // v1: { levels: { "pt:porto": 3, ... } }
      if (!o || typeof o !== "object") return defaultOptions();
      if (o.cfg && typeof o.cfg === "object") return o;
      const out = { cfg: {} };
      const levels = (o.levels && typeof o.levels === "object") ? o.levels : {};
      for (const [packId, lvl] of Object.entries(levels)) {
        const L = Number(lvl || 0);
        if (L >= 1 && L <= 4) out.cfg[packId] = { ...makeEmptyCfg(), identify: L };
      }
      if (Object.keys(out.cfg).length === 0) return defaultOptions();
      return out;
    }

    function loadOptions() {
      try {
        const raw = localStorage.getItem(OPT_KEY);
        if (!raw) return defaultOptions();
        const o = migrateV1ToV2(JSON.parse(raw));
        if (!o.cfg || typeof o.cfg !== "object") o.cfg = {};
        return o;
      } catch {
        return defaultOptions();
      }
    }
    function saveOptions(o) { localStorage.setItem(OPT_KEY, JSON.stringify(o)); }

    function ensurePackCfg(o, packId) {
      if (!o.cfg) o.cfg = {};
      if (!o.cfg[packId] || typeof o.cfg[packId] !== "object") o.cfg[packId] = makeEmptyCfg();
      for (const c of CATEGORIES) {
        if (c.id === "flags") continue;
        if (o.cfg[packId][c.id] == null) o.cfg[packId][c.id] = 0;
      }
      return o.cfg[packId];
    }

    function packIsPlayable(cfg) {
      if (!cfg) return false;
      return ["identify","pop","area","dens"].some(k => Number(cfg[k] || 0) >= 1 && Number(cfg[k] || 0) <= 4);
    }

    function getSelectedPacksFromOptions(o) {
      const packs = getAllPacks();
      const selected = [];
      for (const p of packs) {
        const cfg = ensurePackCfg(o, p.id);
        if (packIsPlayable(cfg)) selected.push({ ...p, cfg });
      }
      return selected;
    }

    function countSelectedPacks(o, regionFilterFn) {
      const packs = getAllPacks().filter(regionFilterFn);
      let sel = 0;
      for (const p of packs) {
        const cfg = ensurePackCfg(o, p.id);
        if (packIsPlayable(cfg)) sel++;
      }
      return sel;
    }

    let optionsDraft = loadOptions();

    function renderOptionsBlocks(containerEl, selectedCountEl, packs) {
      containerEl.innerHTML = "";
      for (const p of packs) {
        const cfg = ensurePackCfg(optionsDraft, p.id);

        const packDiv = document.createElement("div");
        packDiv.className = "optPack";

        const head = document.createElement("div");
        head.className = "optPackHead";
        const activeTxt = packIsPlayable(cfg) ? "Ativo" : "Inativo";
        head.innerHTML = `<div>${p.label}<div class="sub">${activeTxt}</div></div>`;
        packDiv.appendChild(head);

        const catHead = document.createElement("div");
        catHead.className = "optCatHead";
        catHead.innerHTML = `
          <div class="c">Categoria</div>
          <div class="c">1</div>
          <div class="c">2</div>
          <div class="c">3</div>
          <div class="c">4</div>
        `;
        packDiv.appendChild(catHead);

        for (const cat of CATEGORIES) {
          if (cat.id === "flags") continue; // apenas previsto

          const row = document.createElement("div");
          row.className = "optCatRow";
          row.dataset.pack = p.id;
          row.dataset.cat = cat.id;

          const labelCell = document.createElement("div");
          labelCell.className = "c";
          labelCell.textContent = cat.label;
          row.appendChild(labelCell);

          const cur = Number(cfg[cat.id] || 0);

          for (let L = 1; L <= 4; L++) {
            const cell = document.createElement("div");
            cell.className = "c dotCell";

            const dot = document.createElement("span");
            dot.className = "dot" + (cur === L ? " on" : "");
            dot.title = `Nível ${L}`;

            dot.addEventListener("click", () => {
              const cfg2 = ensurePackCfg(optionsDraft, p.id);
              const cur2 = Number(cfg2[cat.id] || 0);
              if (cur2 === L) cfg2[cat.id] = 0;
              else cfg2[cat.id] = L;
              renderOptionsBlocks(containerEl, selectedCountEl, packs);
            });

            cell.appendChild(dot);
            row.appendChild(cell);
          }

          packDiv.appendChild(row);
        }

        containerEl.appendChild(packDiv);
      }

      // update counter
      let sel = 0;
      for (const p of packs) {
        const cfg = ensurePackCfg(optionsDraft, p.id);
        if (packIsPlayable(cfg)) sel++;
      }
      selectedCountEl.textContent = `Selecionados: ${sel}`;
    }

    // DISTRITOS SCREEN
    const optDistrictsBlocks = document.getElementById("optDistrictsBlocks");
    const optSelectedCountDistricts = document.getElementById("optSelectedCountDistricts");
    const btnOptBackDistricts = document.getElementById("btnOptBackDistricts");
    const btnOptBackTopDistricts = document.getElementById("btnOptBackTopDistricts");
    const btnOptSaveDistricts = document.getElementById("btnOptSaveDistricts");
    const btnOptResetDistricts = document.getElementById("btnOptResetDistricts");

    function openOptionsDistricts() {
      optionsDraft = loadOptions();
      const packs = getAllPacks().filter(p => p.region === "pt");
      renderOptionsBlocks(optDistrictsBlocks, optSelectedCountDistricts, packs);
      showScreen(screenOptionsDistricts);
    }
    function closeDistrictsToOptionsMenu() { showScreen(screenOptionsMenu); }

    btnOptBackDistricts.addEventListener("click", () => closeDistrictsToOptionsMenu());
    btnOptBackTopDistricts.addEventListener("click", () => closeDistrictsToOptionsMenu());

    btnOptResetDistricts.addEventListener("click", () => {
      optionsDraft = defaultOptions();
      // limpar tudo nos distritos, depois reativar porto identify=3
      const packs = getAllPacks().filter(p => p.region === "pt");
      for (const p of packs) optionsDraft.cfg[p.id] = makeEmptyCfg();
      optionsDraft.cfg["pt:porto"] = { ...makeEmptyCfg(), identify: 3 };
      renderOptionsBlocks(optDistrictsBlocks, optSelectedCountDistricts, packs);
    });

    btnOptSaveDistricts.addEventListener("click", () => {
      const selected = getSelectedPacksFromOptions(optionsDraft);
      if (selected.length === 0) {
        alert("Seleciona pelo menos 1 distrito/região com alguma categoria ativa.");
        return;
      }
      saveOptions(optionsDraft);
      closeDistrictsToOptionsMenu();
    });

    // REGIÕES AUTÓNOMAS SCREEN
    const optRABlocks = document.getElementById("optRABlocks");
    const optSelectedCountRA = document.getElementById("optSelectedCountRA");
    const btnOptBackRA = document.getElementById("btnOptBackRA");
    const btnOptBackTopRA = document.getElementById("btnOptBackTopRA");
    const btnOptSaveRA = document.getElementById("btnOptSaveRA");
    const btnOptResetRA = document.getElementById("btnOptResetRA");

    function openOptionsRA() {
      optionsDraft = loadOptions();
      const packs = getAllPacks().filter(p => (p.region === "az" || p.region === "md"));
      renderOptionsBlocks(optRABlocks, optSelectedCountRA, packs);
      showScreen(screenOptionsRA);
    }
    function closeRAToOptionsMenu() { showScreen(screenOptionsMenu); }

    btnOptBackRA.addEventListener("click", () => closeRAToOptionsMenu());
    btnOptBackTopRA.addEventListener("click", () => closeRAToOptionsMenu());

    btnOptResetRA.addEventListener("click", () => {
      optionsDraft = loadOptions();
      const packs = getAllPacks().filter(p => (p.region === "az" || p.region === "md"));
      for (const p of packs) optionsDraft.cfg[p.id] = makeEmptyCfg();
      renderOptionsBlocks(optRABlocks, optSelectedCountRA, packs);
    });

    btnOptSaveRA.addEventListener("click", () => {
      const selected = getSelectedPacksFromOptions(optionsDraft);
      if (selected.length === 0) {
        alert("Seleciona pelo menos 1 distrito/região com alguma categoria ativa.");
        return;
      }
      saveOptions(optionsDraft);
      closeRAToOptionsMenu();
    });

    /* =========================
       DEMOGRAFIA
       ========================= */
    let demografiaByNmKey = null; // { "nm:porto": { municipio, pop, area_km2, dens_pop_km2 }, ... }

    async function ensureDemografiaLoaded() {
      if (demografiaByNmKey) return demografiaByNmKey;
      demografiaByNmKey = await loadJSON(FILES.demografia);
      return demografiaByNmKey;
    }

    function getDemoNmKeyForMunicipalityName(name) {
      return `nm:${normalize(name)}`;
    }

    function fmtInt(n) {
      const x = Math.round(Number(n) || 0);
      return x.toLocaleString("pt-PT");
    }
    function fmtFloat(n, digits=2) {
      const x = Number(n);
      if (!Number.isFinite(x)) return "—";
      return x.toFixed(digits).replace(".", ",");
    }

    function parseUserNumber(s) {
      const raw = (s || "").trim();
      if (!raw) return NaN;
      // aceitar vírgula e ponto; remover espaços
      let t = raw.replace(/\s+/g, "");
      // se tiver ambos, assume que o último separador é decimal e remove o outro como separador de milhar
      const hasDot = t.includes(".");
      const hasComma = t.includes(",");
      if (hasDot && hasComma) {
        const lastDot = t.lastIndexOf(".");
        const lastComma = t.lastIndexOf(",");
        const decIsComma = lastComma > lastDot;
        const dec = decIsComma ? "," : ".";
        const thou = decIsComma ? "." : ",";
        t = t.split(thou).join("");
        t = t.replace(dec, ".");
      } else {
        t = t.replace(",", ".");
      }
      return Number(t);
    }

    function withinPct(userVal, realVal, pct=0.10) {
      const u = Number(userVal);
      const r = Number(realVal);
      if (!Number.isFinite(u) || !Number.isFinite(r)) return false;
      if (r === 0) return Math.abs(u - r) <= 0.0001;
      return (Math.abs(u - r) / Math.abs(r)) <= pct;
    }

    // População: escalões fixos
    const POP_BINS = [
      { max: 2000, label: "< 2 000" },
      { max: 5000, label: "< 5 000" },
      { max: 10000, label: "< 10 000" },
      { max: 20000, label: "< 20 000" },
      { max: 50000, label: "< 50 000" },
      { max: 100000, label: "< 100 000" },
      { max: 200000, label: "< 200 000" },
      { max: Infinity, label: "> 200 000" },
    ];
    function popBinForValue(v) {
      const n = Number(v);
      for (const b of POP_BINS) {
        if (n < b.max) return b.label;
      }
      return POP_BINS[POP_BINS.length-1].label;
    }

    /* =========================
       LEAFLET
       ========================= */
    let map = null;
    let fillLayer = null;

    let insetMap = null;
    let insetLayer = null;
    let insetRect = null;

    let lastCleanedGeoJSON = null;
    let insetPrimed = false;

    let byKey = new Map();
    let keyToOfficial = new Map();

    let keyToIsland = new Map();
    let islandToBounds = new Map();

    let keyToBounds = new Map();

    function resetLeafletContainer(containerId) {
      const el = document.getElementById(containerId);
      if (!el) return;

      if (el._leaflet_id) {
        try { delete el._leaflet_id; } catch { el._leaflet_id = null; }
      }
      if (el.innerHTML && el.innerHTML.length) el.innerHTML = "";
    }

    function ensureMapReady() {
      if (map) return;
      resetLeafletContainer("map");
      map = L.map("map", {
        zoomControl: false,
        attributionControl: false,
        zoomAnimation: false,
        fadeAnimation: false,
        markerZoomAnimation: false
      });
      map.setView([39.5, -8.0], 7);
    }

    function ensureInsetReady() {
      if (insetMap) return;
      resetLeafletContainer("insetMap");
      insetMap = L.map("insetMap", {
        zoomControl: false,
        attributionControl: false,
        dragging: false,
        touchZoom: false,
        doubleClickZoom: false,
        scrollWheelZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomAnimation: false,
        fadeAnimation: false,
        markerZoomAnimation: false
      });
      insetMap.setView([39.5, -8.0], 7);
    }

    function destroyMaps() {
      try { if (fillLayer) { fillLayer.remove(); } } catch {}
      try { if (insetLayer) { insetLayer.remove(); } } catch {}
      try { if (insetRect) { insetRect.remove(); } } catch {}
      fillLayer = null;
      insetLayer = null;
      insetRect = null;

      try { if (map) { map.remove(); } } catch {}
      try { if (insetMap) { insetMap.remove(); } } catch {}
      map = null;
      insetMap = null;

      resetLeafletContainer("map");
      resetLeafletContainer("insetMap");
    }

    function invalidateMapSizeHard() {
      if (!map) return;
      requestAnimationFrame(() => {
        try { map.invalidateSize(true); } catch {}
        requestAnimationFrame(() => {
          try { map.invalidateSize(true); } catch {}
        });
      });
    }

    function invalidateInsetSizeHard() {
      if (!insetMap) return;
      requestAnimationFrame(() => {
        try { insetMap.invalidateSize(true); } catch {}
        requestAnimationFrame(() => {
          try { insetMap.invalidateSize(true); } catch {}
        });
      });
    }

    function afterNextPaint(fn) { requestAnimationFrame(() => requestAnimationFrame(fn)); }

    function setMapInteractive(enabled) {
      if (!map) return;
      const m = map;
      if (enabled) {
        m.dragging.enable();
        m.touchZoom.enable();
        m.doubleClickZoom.enable();
        m.scrollWheelZoom.enable();
        m.boxZoom.enable();
        m.keyboard.enable();
        if (m.tap) m.tap.enable();
      } else {
        m.dragging.disable();
        m.touchZoom.disable();
        m.doubleClickZoom.disable();
        m.scrollWheelZoom.disable();
        m.boxZoom.disable();
        m.keyboard.disable();
        if (m.tap) m.tap.disable();
      }
    }

    function clearLayer() {
      if (fillLayer) fillLayer.remove();
      fillLayer = null;

      if (insetLayer) insetLayer.remove();
      insetLayer = null;

      if (insetRect) insetRect.remove();
      insetRect = null;

      lastCleanedGeoJSON = null;

      byKey.clear();
      keyToOfficial.clear();

      keyToIsland.clear();
      islandToBounds.clear();
      keyToBounds.clear();
    }

    /* =========================
       GAME STATE
       ========================= */
    let playActive = false;

    let selectedPacks = [];
    let currentPack = null;

    // current question
    let currentCategory = "identify"; // identify|pop|area|dens
    let playLevel = 3;

    let playPoolKeys = [];
    let playRemainingKeys = [];
    let currentTargetKey = "";

    // generic choices
    let currentChoiceItems = []; // {id,label}
    let correctChoiceId = "";

    let hintUsedThisRound = false;

    let roundStartedAt = 0;
    let timerHandle = null;

    let sessionIndex = 0;
    let sessionCorrect = 0;
    let sessionWrong = 0;
    let sessionXP = 0;

    let awaitingTap = false;
    let inputBlockedUntil = 0;
    let transitioning = false;

    let suppressChoiceUntil = 0;

    // nível 4
    let playPoolEntries = [];
    let lvl4Typed = "";
    let lvl4Suggest = [];
    let level4HintChoiceMode = false;
    let lvl4KeyboardMode = "text"; // text|num

    // demografia target
    let currentDemoRealValue = null; // number
    let currentDemoUnit = "";
    let currentDemoLabel = "";

    function stopTimer() {
      if (timerHandle) clearInterval(timerHandle);
      timerHandle = null;
    }

    function lockChoices(locked) {
      const btns = choicesEl.querySelectorAll("button.choiceBtn");
      btns.forEach(b => b.disabled = !!locked);
    }

    function styleFill(feature) {
      const key = getMunicipalityKey(feature.properties || {});
      if (playActive) {
        const isTarget = (key && key === currentTargetKey);
        return { color:"#000", weight: isTarget ? 2.0 : 1.1, fillColor: isTarget ? "#c00" : "#fff", fillOpacity: 1 };
      }
      return { color:"#000", weight: 1.1, fillColor:"#fff", fillOpacity: 1 };
    }

    function refreshStyles() {
      if (fillLayer) fillLayer.setStyle(styleFill);
      if (insetLayer) insetLayer.setStyle(styleFill);
    }

    function rebuildPlayPoolEntries() {
      const arr = [];
      for (const [k, name] of keyToOfficial.entries()) {
        arr.push({ key: k, name: (name || k), norm: normalize(name || k) });
      }
      arr.sort((a,b) => (a.name || "").localeCompare((b.name || ""), "pt", { sensitivity: "base" }));
      playPoolEntries = arr;
    }

    function buildLayer(fc) {
      ensureMapReady();
      clearLayer();

      const { cleaned } = sanitizeFeatureCollection(fc);
      if (!cleaned.features || cleaned.features.length === 0) {
        throw new Error("GeoJSON sem features válidas (após limpeza).");
      }

      lastCleanedGeoJSON = cleaned;

      fillLayer = L.geoJSON(cleaned, {
        style: styleFill,
        onEachFeature: (feature, layer) => {
          const raw = getMunicipalityName(feature.properties || {});
          const key = getMunicipalityKey(feature.properties || {});
          if (!key) return;

          byKey.set(key, true);
          keyToOfficial.set(key, raw);

          try {
            const bKey = layer.getBounds?.();
            if (bKey && bKey.isValid && bKey.isValid()) keyToBounds.set(key, bKey);
          } catch {}

          const ilha = getIslandName(feature.properties || {});
          if (ilha) {
            keyToIsland.set(key, ilha);
            try {
              const b = layer.getBounds?.();
              if (b && b.isValid && b.isValid()) {
                const cur = islandToBounds.get(ilha);
                islandToBounds.set(ilha, cur ? cur.extend(b) : b);
              }
            } catch {}
          }
        }
      }).addTo(map);

      invalidateMapSizeHard();

      try {
        const b = fillLayer.getBounds();
        if (b && b.isValid && b.isValid()) {
          map.fitBounds(b, { padding: [8, 8], animate: false });
        }
      } catch {}
    }

    async function loadConcelhosFCForPack(pack) {
      setLoading(`A carregar: ${pack.label}`, 55);

      if (pack.region === "pt") {
        const url = FILES.concelhosPT(pack.slug);
        const fc = await loadJSON(url);
        const check = assertGeoJSONLooksLikeLonLat(fc);
        if (!check.ok) throw new Error(`GeoJSON inválido: ${check.reason} (${url})`);
        return fc;
      }

      const url = (pack.region === "az") ? FILES.concelhosAZ : FILES.concelhosMD;
      const fc = await loadJSON(url);
      const check = assertGeoJSONLooksLikeLonLat(fc);
      if (!check.ok) throw new Error(`GeoJSON inválido: ${check.reason} (${url})`);
      return fc;
    }

    function startTimer() {
      stopTimer();
      roundStartedAt = Date.now();

      timerHandle = setInterval(() => {
        if (!playActive) return;
        if (awaitingTap) return;
        if (transitioning) return;

        const elapsed = (Date.now() - roundStartedAt) / 1000;
        const remain = Math.max(0, PLAY.TIME_LIMIT_SEC - elapsed);

        timeLine.textContent = String(Math.ceil(remain));

        if (remain <= 0) {
          stopTimer();
          onTimeout();
        }
      }, 100);
    }

    function computeXPForCorrect(elapsedSec, level, usedHint) {
      const t = Math.max(0, Math.min(PLAY.TIME_LIMIT_SEC, elapsedSec));
      const timeFactor = (PLAY.TIME_LIMIT_SEC - t) / PLAY.TIME_LIMIT_SEC;
      const base = 10;
      const bonus = Math.round(40 * timeFactor);
      let xp = base + bonus;
      const eff = (level === 4 ? 3 : level);
      xp = xp * PLAY.difficultyMultByLevel(eff);
      if (usedHint) xp = xp * PLAY.hintMult;
      return Math.max(0, Math.floor(xp));
    }

    function pickPackAndCategoryForRound() {
      const pack = selectedPacks[Math.floor(Math.random() * selectedPacks.length)];
      const enabled = [];
      for (const cat of ["identify","pop","area","dens"]) {
        const L = Number(pack.cfg?.[cat] || 0);
        if (L >= 1 && L <= 4) enabled.push(cat);
      }
      const cat = enabled[Math.floor(Math.random() * enabled.length)] || "identify";
      return { pack, cat, level: Number(pack.cfg?.[cat] || 3) };
    }

    function pickNewTargetKey() {
      if (playRemainingKeys.length === 0) playRemainingKeys = shuffle(playPoolKeys);
      return playRemainingKeys.pop() || "";
    }

    function setStageMode(mode) {
      // mode: "map" | "text"
      if (!gameStageEl) return;
      const isText = (mode === "text");
      gameStageEl.classList.toggle("textMode", isText);
      if (stageText) stageText.style.display = isText ? "flex" : "none";
      if (!isText) {
        setTimeout(invalidateMapSizeHard, 0);
        setTimeout(invalidateMapSizeHard, 120);
      }
    }

    function updateStageTextForDemografia() {
      const mun = keyToOfficial.get(currentTargetKey) || "—";
      if (stageMunicipio) stageMunicipio.textContent = mun;
      if (stageTipo) stageTipo.textContent = currentDemoLabel || "—";
    }

    function buildChoiceItemsForIdentify(level) {
      const effectiveLevel = (level === 4) ? 3 : level;
      const n = PLAY.optionsByLevel(effectiveLevel);
      const forbid = new Set([currentTargetKey]);
      const wrong = sampleDistinct(playPoolKeys, n - 1, forbid);
      const keys = shuffle([currentTargetKey, ...wrong]);
      currentChoiceItems = keys.map(k => ({ id: k, label: keyToOfficial.get(k) || k }));
      correctChoiceId = currentTargetKey;
    }

    async function buildChoiceItemsForDemografia(cat, level) {
      await ensureDemografiaLoaded();

      const munName = keyToOfficial.get(currentTargetKey) || "";
      const nmKey = getDemoNmKeyForMunicipalityName(munName);
      const rec = demografiaByNmKey?.[nmKey];

      if (!rec) {
        // fallback: se não houver demografia, volta a identificação
        currentCategory = "identify";
        currentDemoRealValue = null;
        currentDemoUnit = "";
        currentDemoLabel = "";
        buildChoiceItemsForIdentify(level);
        return;
      }

      let realVal = null;
      let unit = "";
      let label = "";

      if (cat === "pop") { realVal = Number(rec.pop); unit = "habitantes"; label = "População (habitantes)"; }
      if (cat === "area") { realVal = Number(rec.area_km2); unit = "km²"; label = "Área (km²)"; }
      if (cat === "dens") { realVal = Number(rec.dens_pop_km2); unit = "hab/km²"; label = "Densidade (hab/km²)"; }

      currentDemoRealValue = realVal;
      currentDemoUnit = unit;
      currentDemoLabel = label;

      if (level === 4) {
        // modo de escrita numérica: sem escolhas (exceto confirmar)
        currentChoiceItems = [];
        correctChoiceId = "";
        return;
      }

      const n = PLAY.optionsByLevel(level);

      if (cat === "pop") {
        const correct = popBinForValue(realVal);
        // nível 3: podemos mostrar tudo (8 bins)
        let pool = POP_BINS.map(b => b.label);
        if (n < pool.length) {
          // manter o correto e escolher (n-1) outros
          const others = pool.filter(x => x !== correct);
          const picked = shuffle(others).slice(0, Math.max(0, n-1));
          pool = shuffle([correct, ...picked]);
        } else {
          pool = shuffle(pool);
        }
        currentChoiceItems = pool.slice(0, n).map(lbl => ({ id: lbl, label: lbl }));
        correctChoiceId = correct;
        return;
      }

      // area / dens: usar valores reais de outros municípios como distrações
      const forbid = new Set([currentTargetKey]);
      const wrongKeys = sampleDistinct(playPoolKeys, Math.max(0, n-1), forbid);
      const allKeys = shuffle([currentTargetKey, ...wrongKeys]);

      function valueForKey(k) {
        const nm = getDemoNmKeyForMunicipalityName(keyToOfficial.get(k) || "");
        const r = demografiaByNmKey?.[nm];
        if (!r) return null;
        if (cat === "area") return Number(r.area_km2);
        if (cat === "dens") return Number(r.dens_pop_km2);
        return null;
      }

      const items = [];
      for (const k of allKeys) {
        const v = valueForKey(k);
        if (!Number.isFinite(v)) continue;
        const digits = (cat === "area") ? 2 : 1;
        const lbl = `${fmtFloat(v, digits)} ${unit}`;
        items.push({ id: String(v), label: lbl, _k:k });
      }

      // garantir que temos n opções; se faltarem, amostrar mais
      if (items.length < n) {
        const need = n - items.length;
        const extra = sampleDistinct(playPoolKeys, need + 8, new Set(allKeys));
        for (const k of extra) {
          if (items.length >= n) break;
          const v = valueForKey(k);
          if (!Number.isFinite(v)) continue;
          const digits = (cat === "area") ? 2 : 1;
          const lbl = `${fmtFloat(v, digits)} ${unit}`;
          items.push({ id: String(v), label: lbl, _k:k });
        }
      }

      const unique = [];
      const seen = new Set();
      for (const it of items) {
        if (seen.has(it.label)) continue;
        seen.add(it.label);
        unique.push(it);
        if (unique.length >= n) break;
      }

      currentChoiceItems = shuffle(unique.map(it => ({ id: it.id, label: it.label })));
      correctChoiceId = String(realVal);
    }

    function renderHUD() {
      const shown = awaitingTap
        ? Math.min(sessionIndex, QUESTIONS_PER_SESSION)
        : Math.min(sessionIndex + 1, QUESTIONS_PER_SESSION);

      sessionLine.textContent = `${shown}/${QUESTIONS_PER_SESSION}`;
      btnHint.disabled = (!playActive) || awaitingTap || hintUsedThisRound || transitioning;
    }

    
    function sortNumericChoicesIfNeeded() {
      if (!currentCategory || currentCategory === "identify") return;
      // detect numeric labels
      if (!currentChoiceItems || currentChoiceItems.length < 2) return;
      const parsed = currentChoiceItems.map(it => {
        const m = String(it.label).match(/([-\d.,]+)/);
        const v = m ? parseUserNumber(m[1]) : NaN;
        return { it, v };
      });
      if (parsed.every(x => Number.isFinite(x.v))) {
        parsed.sort((a,b) => a.v - b.v);
        currentChoiceItems = parsed.map(x => x.it);
      }
    }

function renderChoicesFromItems() {
      sortNumericChoicesIfNeeded();
      choicesEl.innerHTML = "";
      for (const it of currentChoiceItems) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "choiceBtn";
        b.dataset.id = it.id;
        b.textContent = it.label;

        b.addEventListener("click", (e) => {
          e.stopPropagation();
          if (Date.now() < suppressChoiceUntil) return;
          if (Date.now() < inputBlockedUntil) return;
          if (transitioning) return;
          submitAnswerChoice(it.id);
        });

        choicesEl.appendChild(b);
      }
    }

    // ===== NÍVEL 4 =====
    function setLevel4UI(on) {
      lvl4Bar.style.display = on ? "block" : "none";
      lvl4Keyboard.style.display = on ? "flex" : "none";
      if (!on) lvl4Keyboard.classList.remove("disabled");
    }
    function setLevel4TypedText(s) {
      const t = (s && s.length) ? s.toUpperCase() : "—";
      lvl4TypedEl.textContent = t;
    }

    function setKeyboardMode(mode) {
      if (lvl4KeyboardMode === mode) return;
      lvl4KeyboardMode = mode;
      buildKeyboard(mode);
    }

    function getLevel4Suggestions() {
      const pref = normalize(lvl4Typed);
      if (!pref) return [];
      const out = [];
      for (const e of playPoolEntries) {
        if (e.norm.startsWith(pref)) out.push(e);
        if (out.length >= 4) break;
      }
      return out;
    }

    function renderLevel4Suggestions() {
      lvl4Suggest = getLevel4Suggestions();
      setLevel4TypedText(lvl4Typed);

      const slots = lvl4Suggest.slice(0,4);
      while (slots.length < 4) slots.push(null);

      choicesEl.innerHTML = "";

      for (const item of slots) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "choiceBtn";

        if (!item) {
          b.classList.add("ghost");
          b.disabled = true;
          b.textContent = "";
        } else {
          b.dataset.id = item.key;
          b.textContent = item.name;
          b.disabled = awaitingTap || transitioning || (Date.now() < suppressChoiceUntil) || (Date.now() < inputBlockedUntil);

          b.addEventListener("click", (e) => {
            e.stopPropagation();
            if (Date.now() < suppressChoiceUntil) return;
            if (Date.now() < inputBlockedUntil) return;
            if (transitioning) return;
            submitAnswerChoice(item.key);
          });
        }

        choicesEl.appendChild(b);
      }
    }

    function renderLevel4NumericConfirm() {
      setLevel4TypedText(lvl4Typed ? `${lvl4Typed} ${currentDemoUnit}` : "—");
      choicesEl.innerHTML = "";

      const confirm = document.createElement("button");
      confirm.type = "button";
      confirm.className = "choiceBtn";
      confirm.textContent = "Confirmar";
      confirm.addEventListener("click", (e) => {
        e.stopPropagation();
        if (Date.now() < suppressChoiceUntil) return;
        if (Date.now() < inputBlockedUntil) return;
        if (transitioning) return;
        submitLevel4Numeric();
      });
      choicesEl.appendChild(confirm);

      // manter o grid "limpo" (sem ocupar espaço)
      for (let i=0;i<3;i++){
        const g = document.createElement("button");
        g.type="button";
        g.className="choiceBtn ghost";
        g.disabled=true;
        g.textContent="";
        choicesEl.appendChild(g);
      }
    }

    function submitLevel4Numeric() {
      if (!playActive || awaitingTap || transitioning) return;
      if (Date.now() < suppressChoiceUntil) return;
      if (Date.now() < inputBlockedUntil) return;

      stopTimer();
      const elapsed = (Date.now() - roundStartedAt) / 1000;

      sessionIndex++;

      const userVal = parseUserNumber(lvl4Typed);
      const isCorrect = withinPct(userVal, currentDemoRealValue, 0.10);

      if (isCorrect) {
        sessionCorrect++;
        sessionXP += computeXPForCorrect(elapsed, 4, hintUsedThisRound);
      } else {
        sessionWrong++;
      }

      awaitingTap = true;
      inputBlockedUntil = Date.now() + 250;

      lvl4Keyboard.classList.add("disabled");

      const digits = (currentCategory === "area") ? 2 : (currentCategory === "dens" ? 1 : 0);
      const realText = (currentCategory === "pop")
        ? `${fmtInt(currentDemoRealValue)} ${currentDemoUnit}`
        : `${fmtFloat(currentDemoRealValue, digits)} ${currentDemoUnit}`;

      const btn = choicesEl.querySelector("button.choiceBtn");
      if (btn) {
        btn.classList.add(isCorrect ? "correct" : "wrong");
        btn.disabled = true;

        if (isCorrect) {
          // quando acerta, o botão fica verde e mostra o valor real
          btn.textContent = realText;
        } else {
          // quando erra, mostra o valor real a verde abaixo
          const pill = document.createElement("button");
          pill.type = "button";
          pill.className = "choiceBtn correct";
          pill.disabled = true;
          pill.style.cursor = "default";
          pill.textContent = realText;
          btn.insertAdjacentElement("afterend", pill);
        }
      }

  renderHUD();
}

    function level4HandleKey(code) {
      if (!playActive || awaitingTap || transitioning) return;
      if (level4HintChoiceMode) return;

      if (lvl4KeyboardMode === "text") {
        if (code === "BACK") {
          lvl4Typed = lvl4Typed.slice(0, -1);
        } else if (code === "SPACE") {
          if (lvl4Typed.length && !lvl4Typed.endsWith(" ")) lvl4Typed += " ";
        } else {
          if (lvl4Typed.length < 28) lvl4Typed += code;
        }
        renderLevel4Suggestions();
        return;
      }

      // numérico
      if (code === "BACK") {
        lvl4Typed = lvl4Typed.slice(0, -1);
      } else if (code === "." || code === ",") {
        if (!lvl4Typed.includes(".") && !lvl4Typed.includes(",")) {
          lvl4Typed = (lvl4Typed.length ? lvl4Typed : "0") + code;
        }
      } else {
        // digits (inclui 00 / 000)
        if ((lvl4Typed.length + String(code).length) <= 14) lvl4Typed += String(code);
      }
      renderLevel4NumericConfirm();
    }

    function onTimeout() {
      if (!playActive || awaitingTap || transitioning) return;

      sessionWrong++;
      sessionIndex++;

      awaitingTap = true;
      inputBlockedUntil = Date.now() + 250;

      if (playLevel === 4 && !level4HintChoiceMode) {
        lvl4Keyboard.classList.add("disabled");
        choicesEl.innerHTML = "";

        if (currentCategory === "identify") {
          const correctName = keyToOfficial.get(currentTargetKey) || "";
          const b = document.createElement("button");
          b.type = "button";
          b.className = "choiceBtn correct";
          b.disabled = true;
          b.textContent = correctName;
          choicesEl.appendChild(b);
        } else {
          const digits = (currentCategory === "area") ? 2 : (currentCategory === "dens" ? 1 : 0);
          const realText = (currentCategory === "pop")
            ? `${fmtInt(currentDemoRealValue)} ${currentDemoUnit}`
            : `${fmtFloat(currentDemoRealValue, digits)} ${currentDemoUnit}`;

          const b = document.createElement("button");
          b.type = "button";
          b.className = "choiceBtn correct";
          b.disabled = true;
          b.textContent = realText;
          choicesEl.appendChild(b);
        }

        renderHUD();
        return;
      }

      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      for (const b of btns) {
        const id = b.dataset.id || "";
        if (id === correctChoiceId) b.classList.add("correct");
      }
      lockChoices(true);
      renderHUD();
    }

    async function ensurePackLoaded(pack) {
      if (currentPack && currentPack.id === pack.id) return;

      transitioning = true;
      lockChoices(true);
      stopTimer();

      currentPack = pack;

      setLoading(`A preparar: ${pack.label}`, 65);
      const fc = await loadConcelhosFCForPack(pack);

      setLoading("A desenhar…", 85);
      buildLayer(fc);

      invalidateMapSizeHard();
      setTimeout(invalidateMapSizeHard, 200);

      playPoolKeys = Array.from(keyToOfficial.keys());
      playRemainingKeys = shuffle(playPoolKeys);

      rebuildPlayPoolEntries();

      insetPrimed = false;
      if (insetLayer) { insetLayer.remove(); insetLayer = null; }
      if (insetRect) { insetRect.remove(); insetRect = null; }

      transitioning = false;
    }

    function updateAzoresInsetForCurrentTarget() {
      if (!currentPack || currentPack.region !== "az") {
        insetWrap.classList.remove("show");
        if (insetRect) { insetRect.remove(); insetRect = null; }
        return;
      }

      insetWrap.classList.add("show");

      afterNextPaint(() => {
        if (!insetMap) {
          ensureInsetReady();
          insetPrimed = false;
        }

        if (!insetLayer && insetMap && lastCleanedGeoJSON) {
          insetLayer = L.geoJSON(lastCleanedGeoJSON, { style: styleFill }).addTo(insetMap);
        }

        invalidateInsetSizeHard();

        afterNextPaint(() => {
          invalidateInsetSizeHard();

          const runZoom = () => {
            const ilha = keyToIsland.get(currentTargetKey);
            const b =
              (ilha && islandToBounds.get(ilha)) ? islandToBounds.get(ilha)
              : keyToBounds.get(currentTargetKey);

            if (b && b.isValid && b.isValid()) {
              const usedB = safeZoomToBounds(
                insetMap,
                b,
                { padding: [10, 10], animate: false, maxZoom: 12 },
                0.25
              );

              if (insetRect) insetRect.remove();
              if (usedB) insetRect = L.rectangle(usedB, { color: "#000", weight: 2, fillOpacity: 0 }).addTo(map);
            }
            insetPrimed = true;
          };

          runZoom();
          setTimeout(() => { invalidateInsetSizeHard(); runZoom(); }, 120);
          setTimeout(() => { invalidateInsetSizeHard(); runZoom(); }, 320);

          if (!insetPrimed) {
            setTimeout(() => {
              invalidateInsetSizeHard();
              runZoom();
            }, 60);
          }
        });
      });
    }

    async function nextRound() {
      stopTimer();
      awaitingTap = false;
      hintUsedThisRound = false;
      level4HintChoiceMode = false;
      inputBlockedUntil = Date.now() + 220;
      suppressChoiceUntil = Date.now() + 320;

      const pick = pickPackAndCategoryForRound();
      await ensurePackLoaded(pick.pack);

      currentCategory = pick.cat;
      playLevel = pick.level;

      // Toggle stage presentation: map only for identify; text for demografia
      setStageMode(currentCategory === "identify" ? "map" : "text");

      currentTargetKey = pickNewTargetKey();

      // reset lvl4 typed
      lvl4Typed = "";

      if (currentCategory === "identify") {
        currentDemoRealValue = null;
        currentDemoUnit = "";
        currentDemoLabel = "";

        if (playLevel === 4) {
          correctChoiceId = currentTargetKey;
          setLevel4UI(true);
          setKeyboardMode("text");
          lvl4Keyboard.classList.remove("disabled");
          setLevel4TypedText(lvl4Typed);
          renderLevel4Suggestions();
        } else {
          setLevel4UI(false);
          buildChoiceItemsForIdentify(playLevel);
          renderChoicesFromItems();
          lockChoices(false);
        }
      } else {
        await buildChoiceItemsForDemografia(currentCategory, playLevel);

        if (playLevel === 4 && !level4HintChoiceMode && currentCategory !== "identify") {
          setLevel4UI(true);
          setKeyboardMode("num");
          lvl4Keyboard.classList.remove("disabled");
          renderLevel4NumericConfirm();
        } else {
          setLevel4UI(false);
          renderChoicesFromItems();
          lockChoices(false);
        }
      }

      if (currentCategory !== "identify") updateStageTextForDemografia();

      refreshStyles();
      if (currentCategory === "identify") updateAzoresInsetForCurrentTarget();
      else insetWrap.classList.remove("show");

      timeLine.textContent = String(PLAY.TIME_LIMIT_SEC);
      startTimer();

      renderHUD();
    }

    function endSessionOverlay() {
      stopTimer();
      playActive = false;
      awaitingTap = false;
      inputBlockedUntil = Date.now() + 250;

      finalCorrect.textContent = `Corretas: ${sessionCorrect}/${QUESTIONS_PER_SESSION}`;
      finalXP.textContent = `XP ganho: ${sessionXP}`;
      finalOverlay.classList.add("show");
    }

    function submitAnswerChoice(chosenId) {
      if (!playActive || awaitingTap || transitioning) return;
      if (Date.now() < suppressChoiceUntil) return;
      if (Date.now() < inputBlockedUntil) return;

      stopTimer();
      const elapsed = (Date.now() - roundStartedAt) / 1000;

      sessionIndex++;

      const isCorrect = (chosenId === correctChoiceId);

      if (isCorrect) {
        sessionCorrect++;
        sessionXP += computeXPForCorrect(elapsed, (playLevel === 4 ? 3 : playLevel), hintUsedThisRound);
      } else {
        sessionWrong++;
      }

      awaitingTap = true;
      inputBlockedUntil = Date.now() + 250;

      if (playLevel === 4 && currentCategory === "identify") {
        const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));

        let correctBtn = null;
        let chosenBtn = null;

        for (const b of btns) {
          const id = b.dataset.id || "";
          if (id === chosenId) chosenBtn = b;
          if (id === correctChoiceId) correctBtn = b;
          b.disabled = true;
        }

        if (isCorrect) {
          // correta escolhida → fica verde
          if (chosenBtn) chosenBtn.classList.add("correct");
        } else {
          // errada escolhida → fica vermelha
          if (chosenBtn) chosenBtn.classList.add("wrong");

          if (correctBtn) {
            // a correta já estava visível → pinta a verde
            correctBtn.classList.add("correct");
          } else {
            // a correta NÃO estava nas 4 → substituir uma errada
            const replaceTarget =
              btns.find(b => b !== chosenBtn && (b.dataset.id || "")) ||
              btns.find(b => (b.dataset.id || "")) ||
              chosenBtn;

            if (replaceTarget) {
              replaceTarget.classList.remove("wrong");
              replaceTarget.classList.add("correct");
              replaceTarget.dataset.id = correctChoiceId; // importante
              replaceTarget.textContent = keyToOfficial.get(correctChoiceId) || "—";
            }
          }
        }

        renderHUD();
        return;
      }

      // ===== COMPORTAMENTO NORMAL (níveis 1–3 e demografia) =====
      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      for (const b of btns) {
        const id = b.dataset.id || "";
        if (id === correctChoiceId) b.classList.add("correct");
        if (id === chosenId && !isCorrect) b.classList.add("wrong");
        b.disabled = true;
      }

      renderHUD();
    }

    function useHint() {
      if (!playActive || awaitingTap || hintUsedThisRound || transitioning) return;
      if (Date.now() < inputBlockedUntil) return;

      hintUsedThisRound = true;

      if (playLevel === 4) {
        // no nível 4, a ajuda troca para multi-escolha (8 opções)
        level4HintChoiceMode = true;
        setLevel4UI(false);

        if (currentCategory === "identify") {
          buildChoiceItemsForIdentify(3);
          // forçar 8 opções (nível 3)
          const n = 8;
          const forbid = new Set([currentTargetKey]);
          const wrong = sampleDistinct(playPoolKeys, n - 1, forbid);
          const keys = shuffle([currentTargetKey, ...wrong]);
          currentChoiceItems = keys.map(k => ({ id: k, label: keyToOfficial.get(k) || k }));
          correctChoiceId = currentTargetKey;
          renderChoicesFromItems();
          lockChoices(false);
          renderHUD();
          return;
        }

        // demografia: construir como nível 3 (8 opções)
        buildChoiceItemsForDemografia(currentCategory, 3).then(() => {
          renderChoicesFromItems();
          lockChoices(false);
          renderHUD();
        });
        return;
      }

      // níveis 1–3: remover 2 erradas (se possível), igual ao comportamento anterior
      const wrongIds = currentChoiceItems.map(x => x.id).filter(id => id !== correctChoiceId);
      const removeCount = Math.min(2, Math.max(0, wrongIds.length - 1));
      const toHide = sampleDistinct(wrongIds, removeCount);

      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      for (const b of btns) {
        const id = b.dataset.id || "";
        if (toHide.includes(id)) {
          b.classList.add("hidden");
          b.disabled = true;
        }
      }
      renderHUD();
    }

    async function goNextIfReady() {
      if (transitioning) return;
      if (!awaitingTap) return;
      if (Date.now() < inputBlockedUntil) return;

      if (sessionIndex >= QUESTIONS_PER_SESSION) {
        endSessionOverlay();
        return;
      }

      transitioning = true;
      suppressChoiceUntil = Date.now() + 400;

      await new Promise(r => setTimeout(r, 0));

      try {
        await nextRound();
      } finally {
        transitioning = false;
      }
    }

    
    function buildKeyboard(mode="text") {
      const r1 = lvl4Keyboard.querySelector('.kbRow[data-row="1"]');
      const r2 = lvl4Keyboard.querySelector('.kbRow[data-row="2"]');
      const r3 = lvl4Keyboard.querySelector('.kbRow[data-row="3"]');
      const r4 = lvl4Keyboard.querySelector('.kbRow[data-row="4"]');
      const r5 = lvl4Keyboard.querySelector('.kbRow[data-row="5"]');

      r1.innerHTML = ""; r2.innerHTML = ""; r3.innerHTML = ""; r4.innerHTML = ""; if (r5) r5.innerHTML = "";

      lvl4Keyboard.classList.toggle("num", mode === "num");

      function mkKey(label, code, cls="") {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "kbKey" + (cls ? " " + cls : "");
        b.textContent = label;

        b.addEventListener("pointerdown", (e) => {
          if (!awaitingTap) e.stopPropagation();
        }, true);

        b.addEventListener("click", (e) => {
          if (!awaitingTap) e.stopPropagation();
          level4HandleKey(code);
        });

        return b;
      }

      if (mode === "text") {
        const rows = [
          ["Q","W","E","R","T","Y","U","I","O","P"],
          ["A","S","D","F","G","H","J","K","L"],
          ["Z","X","C","V","B","N","M"],
        ];

        rows[0].forEach(k => r1.appendChild(mkKey(k, k)));
        rows[1].forEach(k => r2.appendChild(mkKey(k, k)));
        rows[2].forEach(k => r3.appendChild(mkKey(k, k)));

        r4.appendChild(mkKey("⌫", "BACK", "wide"));
        r4.appendChild(mkKey("␣", "SPACE", "space"));
        if (r5) r5.innerHTML = "";
        return;
      }

      ["1","2","3"].forEach(k => r1.appendChild(mkKey(k, k)));
      ["4","5","6"].forEach(k => r2.appendChild(mkKey(k, k)));
      ["7","8","9"].forEach(k => r3.appendChild(mkKey(k, k)));
      ["0","00","000"].forEach(k => r4.appendChild(mkKey(k, k)));
      if (r5) {
        r5.appendChild(mkKey(",", ","));
        r5.appendChild(mkKey(".", "."));
        r5.appendChild(mkKey("⌫", "BACK", "wide"));
      } else {
        r4.appendChild(mkKey("⌫", "BACK", "wide"));
      }
    }

    buildKeyboard("text");


    document.addEventListener("pointerup", async (e) => {
      if (!screenGame.classList.contains("active")) return;
      if (e.target.closest("#btnExit, #btnHint")) return;

      if (finalOverlay.classList.contains("show")) {
        backToMenu();
        return;
      }

      await goNextIfReady();
    }, true);

    finalOverlay.addEventListener("click", (e) => {
      e.stopPropagation();
      backToMenu();
    });

    function resetSession() {
      stopTimer();
      awaitingTap = false;
      transitioning = false;
      inputBlockedUntil = Date.now() + 200;
      suppressChoiceUntil = Date.now() + 300;
      hintUsedThisRound = false;
      level4HintChoiceMode = false;

      sessionIndex = 0;
      sessionCorrect = 0;
      sessionWrong = 0;
      sessionXP = 0;

      playActive = false;
      currentTargetKey = "";
      currentChoiceItems = [];
      correctChoiceId = "";

      finalOverlay.classList.remove("show");

      timeLine.textContent = String(PLAY.TIME_LIMIT_SEC);
      sessionLine.textContent = `1/${QUESTIONS_PER_SESSION}`;
      choicesEl.innerHTML = "";

      setStageMode("map");
      if (stageMunicipio) stageMunicipio.textContent = "—";
      if (stageTipo) stageTipo.textContent = "—";

      setLevel4UI(false);
      lvl4Typed = "";
      setLevel4TypedText(lvl4Typed);

      insetWrap.classList.remove("show");
      if (insetRect) { insetRect.remove(); insetRect = null; }
      insetPrimed = false;
    }

    /* =========================
       VIEWPORT HOOK (MOBILE ROBUST)
       ========================= */
    function hookViewportResize() {
      const onResize = () => {
        if (!screenGame.classList.contains("active")) return;
        invalidateMapSizeHard();
        invalidateInsetSizeHard();
      };

      window.addEventListener("resize", onResize, { passive: true });
      window.addEventListener("orientationchange", onResize, { passive: true });

      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", onResize, { passive: true });
        window.visualViewport.addEventListener("scroll", onResize, { passive: true });
      }
    }
    hookViewportResize();

    async function startGame() {
      document.body.classList.add("playing");
      showScreen(screenLoading);
      setLoading("A iniciar…", 10);

      try {
        const opts = loadOptions();
        selectedPacks = getSelectedPacksFromOptions(opts);
        if (selectedPacks.length === 0) selectedPacks = getSelectedPacksFromOptions(defaultOptions());

        // garantir que demografia está disponível quando necessário (carrega em background)
        ensureDemografiaLoaded().catch(() => {});

        resetSession();
        setLoading("A preparar ecrã…", 25);

        showScreen(screenGame);
        await new Promise(resolve => afterNextPaint(resolve));

        // robustez extra: destruir + reinit sempre ao entrar no jogo
        destroyMaps();
        ensureMapReady();
        setMapInteractive(false);
        invalidateMapSizeHard();

        playActive = true;
        setLoading("Concluído", 100);

        transitioning = true;
        await nextRound();
        transitioning = false;
      } catch (e) {
        console.error(e);
        showScreen(screenMenu);
        document.body.classList.remove("playing");
        alert("Erro a iniciar o jogo. Vê a consola para detalhes.");
      }
    }

    function backToMenu() {
      resetSession();
      destroyMaps();
      clearLayer();
      currentPack = null;

      document.body.classList.remove("playing");
      showScreen(screenMenu);

      setMapInteractive(true);
    }

    btnExit.addEventListener("click", (e) => {
      e.stopPropagation();
      backToMenu();
    });

    btnHint.addEventListener("click", (e) => {
      e.stopPropagation();
      useHint();
    });

    (function init() {
      showScreen(screenMenu);
    })();
  </script>
</body>
</html>
