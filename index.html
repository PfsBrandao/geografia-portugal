<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geografia PT — Jogo</title>
  <link rel="icon" href="data:,">

  <!-- PWA -->
  <link rel="manifest" href="/geografia-portugal/manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">

  <!-- iOS (Add to Home Screen) -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="apple-touch-icon" href="/geografia-portugal/icons/icon-192.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root {
      --bg: #0b0b0f;
      --panel: #efefef;
      --panelBorder: #bdbdbd;
    }

    html, body { height: 100%; }
    body { font-family: Arial, sans-serif; margin: 0; background: #fff; }

    .screen { display: none; height: 100vh; }
    .screen.active { display: block; }

    /* =========================
       MENU (estilo Penpot)
       ========================= */
    .menuWrap {
      min-height: 100dvh;
      background: #e8e9ea;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing: border-box;
    }
    .menuPhone {
      width: min(420px, 94vw);
      background: #0b0b0f;
      border-radius: 22px;
      padding: 16px;
      box-sizing: border-box;
      border: 2px solid rgba(0,0,0,.12);
    }
    .menuLogo {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      background: #000;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      margin-bottom: 14px;
    }
    .menuLogo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display:block;
    }
    .menuBtns {
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .menuBtn {
      width: 100%;
      min-height: 64px;
      border-radius: 16px;
      border: 2px solid rgba(255,255,255,.15);
      background: #b1b2b5;
      font-size: 28px;
      font-weight: 900;
      cursor: pointer;
      user-select:none;
    }
    .menuBtn:active { transform: translateY(1px); }
    .menuBtn.disabled {
      opacity: .55;
      cursor: not-allowed;
      filter: grayscale(0.2);
    }
    .menuBtn.small {
      font-size: 26px;
    }

    /* =========================
       GAME (shell Penpot)
       ========================= */
    body.playing {
      background: var(--bg);
      height: 100dvh;
      overflow: hidden;
    }

    .gameShell {
      height: 100dvh;
      display: grid;
      gap: 10px;
      padding: 10px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      box-sizing: border-box;
      grid-template-rows: 40px 1fr 70px auto;
    }

    .gameTop{
      display:flex;
      align-items:center;
      justify-content:flex-start;
    }
    .exitBtn{
      width: 44px;
      height: 34px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color:#fff;
      font-weight: 900;
      user-select:none;
      cursor:pointer;
    }

    .gameStage {
      background: #eaeaea;
      border-radius: 18px;
      border: 3px solid var(--panelBorder);
      overflow: hidden;
      min-height: 38dvh;
      position: relative;
    }
    #map { height: 100%; width: 100%; background: #fff; }

    body.playing #map {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    body.playing .leaflet-control-zoom,
    body.playing .leaflet-control-attribution { display: none !important; }

    .gameHUD {
      display: grid;
      grid-template-columns: 1fr 1fr 1.2fr; /* Tempo | Questão | Ajuda */
      gap: 10px;
      align-items: stretch;
    }
    .hudBox {
      background: var(--panel);
      border: 2px solid var(--panelBorder);
      border-radius: 14px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      line-height: 1.05;
      padding: 6px;
      box-sizing: border-box;
      user-select: none;
    }
    .hudBox .k { font-size: 12px; color: #222; opacity: .75; }
    .hudBox .v { font-size: 24px; font-weight: 900; color: #111; }

    .hudBtn {
      border-radius: 14px;
      border: 2px solid #cfcfcf;
      font-size: 20px;
      font-weight: 900;
      cursor: pointer;
      background: linear-gradient(#33b5ff, #0c79d6);
      color: #071018;
      user-select: none;
    }
    .hudBtn:disabled { opacity: .6; cursor: not-allowed; }

    .gameBottom {
      background: rgba(16,16,24,.95);
      border-radius: 18px;
      padding: 12px;
      box-sizing: border-box;
      color: #f2f2f2;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      max-height: 46dvh;
    }

    .choices {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      margin-top: 10px;
    }
    .choiceBtn {
      min-height: 54px;
      border-radius: 16px;
      border: 2px solid #cfcfcf;
      font-size: 16px;
      font-weight: 900;
      background: linear-gradient(#33b5ff, #0c79d6);
      color: #071018;
      white-space: normal;
      line-height: 1.1;
      cursor:pointer;
      user-select:none;
    }
    .choiceBtn:active { transform: translateY(1px); }
    .choiceBtn:disabled { opacity: 0.65; cursor: not-allowed; }
    .choiceBtn.hidden { visibility: hidden; }
    .choiceBtn.correct {
      background: #17c964;
      border-color: rgba(0,0,0,.15);
      color: #071018;
    }
    .choiceBtn.wrong {
      background: #ff4d4f;
      border-color: rgba(0,0,0,.15);
      color: #071018;
    }

    .timerWrap {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 999px;
      overflow: hidden;
      height: 12px;
      background: rgba(255,255,255,.18);
    }
    .timerBar {
      height: 100%;
      width: 100%;
      background: #ffffff;
      transition: width 90ms linear;
    }

    .msg {
      margin-top: 10px;
      min-height: 20px;
      font-size: 14px;
      color: rgba(255,255,255,.9);
    }

    .tapHint {
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255,255,255,.75);
      display:none;
    }
    .tapHint.show { display:block; }

    /* Overlay final */
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.58);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing:border-box;
      z-index: 50;
    }
    .overlay.show { display:flex; }
    .overlayCard {
      width: min(420px, 92vw);
      background: #efefef;
      border: 2px solid #bdbdbd;
      border-radius: 18px;
      padding: 16px;
      box-sizing:border-box;
      text-align:center;
    }
    .overlayCard .t {
      font-size: 24px;
      font-weight: 900;
      color: #111;
      margin: 0 0 10px;
    }
    .overlayCard .p {
      font-size: 18px;
      font-weight: 800;
      color: #111;
      margin: 8px 0;
    }
    .overlayCard .s {
      font-size: 13px;
      color: #333;
      margin-top: 10px;
      opacity: .85;
    }

    @media (max-width: 420px) {
      .gameShell { grid-template-rows: 40px 1fr 60px auto; }
      .hudBox .v { font-size: 18px; }
      .hudBtn { font-size: 16px; }
      .gameBottom { max-height: 52dvh; }
    }
    @media (min-width: 900px) {
      .gameShell {
        max-width: 1100px;
        margin: 0 auto;
        grid-template-rows: 40px 0.95fr 70px 1.05fr;
      }
      .gameBottom { max-height: none; }
    }
  </style>
</head>

<body>
  <!-- SCREEN: MENU -->
  <div id="screenMenu" class="screen active">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo" aria-label="Geo-PT">
          <!-- Se tiveres um logo real, mete aqui. Se não, fica este placeholder. -->
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
        </div>

        <div class="menuBtns">
          <button id="btnMenuPlay" class="menuBtn">Jogar</button>
          <button id="btnMenuStudy" class="menuBtn disabled" disabled>Estudar</button>
          <button id="btnMenuProfile" class="menuBtn disabled" disabled>Perfil</button>
          <button id="btnMenuExit" class="menuBtn small">Sair</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SCREEN: GAME -->
  <div id="screenGame" class="screen">
    <div class="gameShell" id="gameShell">
      <div class="gameTop">
        <button id="btnExit" class="exitBtn" type="button">⟵</button>
      </div>

      <div class="gameStage">
        <div id="map"></div>

        <div id="finalOverlay" class="overlay" role="dialog" aria-modal="true">
          <div class="overlayCard">
            <div class="t">Fim!</div>
            <div class="p" id="finalCorrect">Corretas: 0/10</div>
            <div class="p" id="finalXP">XP ganho: 0</div>
            <div class="s">Toca para voltar ao menu</div>
          </div>
        </div>
      </div>

      <div class="gameHUD">
        <div class="hudBox">
          <div class="k">Tempo</div>
          <div class="v"><span id="timeLine">60</span></div>
        </div>

        <div class="hudBox">
          <div class="k">Questão</div>
          <div class="v"><span id="sessionLine">1/10</span></div>
        </div>

        <button class="hudBtn" id="btnHint" type="button">Ajuda</button>
      </div>

      <div class="gameBottom">
        <div class="timerWrap"><div id="timerBar" class="timerBar"></div></div>

        <div class="msg" id="msg"></div>
        <div class="tapHint" id="tapHint">Toca no ecrã para continuar…</div>

        <div class="choices" id="choices"></div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // PWA: registar service worker
    // -----------------------------
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/geografia-portugal/sw.js").catch(() => {});
    }

    // -----------------------------
    // Config (por agora fixo)
    // -----------------------------
    const GAME = {
      QUESTIONS_PER_SESSION: 10,
      TIME_LIMIT_SEC: 60,
      OPTIONS_COUNT: 8,
      DEFAULT_REGION: "pt",
      DEFAULT_DISTRICT: "porto", // troca aqui se quiseres outro por defeito
      // XP simples (podes afinar)
      XP_BASE: 10,
      XP_TIME_BONUS_MAX: 40, // 0..40 conforme rapidez
      XP_HINT_MULT: 0.60
    };

    const FILES = {
      concelhosPT: (districtSlug) => `data/concelhos_${districtSlug}.geojson`,
      concelhosAZ: `data/concelhos_acores.geojson`,
      concelhosMD: `data/concelhos_madeira.geojson`
    };

    // -----------------------------
    // Utilitários
    // -----------------------------
    function normalize(s) {
      return (s || "").trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
    function pickProp(props, keys) {
      for (const k of keys) {
        if (props && props[k] != null && String(props[k]).trim() !== "") return String(props[k]);
      }
      return "";
    }
    function getMunicipalityName(props) {
      return pickProp(props, ["Concelho","CONCELHO","MUNICIPIO","Municipio","MUNICÍPIO","municipio","NAME_2","NAME2","NAME"]);
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function sampleDistinct(arr, n, forbidSet) {
      const pool = [];
      for (const x of arr) {
        if (forbidSet && forbidSet.has(x)) continue;
        pool.push(x);
      }
      return shuffle(pool).slice(0, Math.min(n, pool.length));
    }

    // Cache downloads
    const cache = new Map();
    async function loadJSON(url) {
      if (cache.has(url)) return cache.get(url);
      const p = fetch(url).then(async (r) => {
        if (!r.ok) throw new Error(`Falha a carregar ${url} (HTTP ${r.status})`);
        const txt = await r.text();
        const clean = (txt.charCodeAt(0) === 0xFEFF) ? txt.slice(1) : txt;
        return JSON.parse(clean);
      });
      cache.set(url, p);
      return p;
    }

    // -----------------------------
    // Screens
    // -----------------------------
    const screenMenu = document.getElementById("screenMenu");
    const screenGame = document.getElementById("screenGame");
    function showScreen(el) {
      for (const s of [screenMenu, screenGame]) s.classList.remove("active");
      el.classList.add("active");
    }

    // -----------------------------
    // Menu
    // -----------------------------
    const btnMenuPlay = document.getElementById("btnMenuPlay");
    const btnMenuExit = document.getElementById("btnMenuExit");

    btnMenuPlay.addEventListener("click", async () => {
      await startGameFlow();
    });

    btnMenuExit.addEventListener("click", () => {
      // Browser/PWA não permite "fechar" de forma garantida. Tentamos e, se falhar, avisamos.
      try { window.close(); } catch {}
      // fallback suave
      alert("Para sair, fecha o separador / a app (PWA).");
    });

    // -----------------------------
    // Game UI refs
    // -----------------------------
    const btnExit = document.getElementById("btnExit");
    const timeLine = document.getElementById("timeLine");
    const sessionLine = document.getElementById("sessionLine");
    const btnHint = document.getElementById("btnHint");
    const timerBar = document.getElementById("timerBar");
    const msgEl = document.getElementById("msg");
    const tapHint = document.getElementById("tapHint");
    const choicesEl = document.getElementById("choices");

    const finalOverlay = document.getElementById("finalOverlay");
    const finalCorrect = document.getElementById("finalCorrect");
    const finalXP = document.getElementById("finalXP");

    function setMsg(t) { msgEl.textContent = t || ""; }

    // -----------------------------
    // Leaflet map
    // -----------------------------
    let map = null;
    let fillLayer = null;

    let byKey = new Map();         // key(normalized name) -> leaflet layer
    let keyToOfficial = new Map(); // key -> original label

    function ensureMapReady() {
      if (map) return;

      map = L.map("map", {
        zoomControl: false,
        attributionControl: false,
        zoomAnimation: false,
        fadeAnimation: false,
        markerZoomAnimation: false,
        dragging: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        touchZoom: false
      });

      // Sem tiles/base layer. Só vetores.
      map.setView([39.5, -8.0], 7);
    }

    function invalidateMapSizeHard() {
      if (!map) return;
      requestAnimationFrame(() => {
        try { map.invalidateSize(true); } catch {}
        requestAnimationFrame(() => {
          try { map.invalidateSize(true); } catch {}
        });
      });
    }

    function clearLayer() {
      if (fillLayer) fillLayer.remove();
      fillLayer = null;
      byKey.clear();
      keyToOfficial.clear();
    }

    // Estado de jogo (quiz)
    let playPoolKeys = [];
    let playRemainingKeys = [];
    let currentTargetKey = "";
    let currentTargetOfficial = "";
    let currentChoicesKeys = [];
    let hintUsedThisRound = false;

    let sessionIndex = 0;     // 0..9 (interno)
    let sessionCorrect = 0;
    let sessionXP = 0;

    let timerHandle = null;
    let roundStartedAt = 0;

    let awaitingAdvance = false; // depois de responder/timeout
    let sessionEnded = false;

    function stopTimer() {
      if (timerHandle) clearInterval(timerHandle);
      timerHandle = null;
    }

    function styleFill(feature) {
      const props = feature.properties || {};
      const raw = getMunicipalityName(props);
      const key = normalize(raw);

      const isTarget = (key && key === currentTargetKey);

      // “imagem do município”: no jogo só desenhamos o target
      if (!isTarget) {
        return {
          color: "#000",
          weight: 0,
          fillColor: "#000",
          fillOpacity: 0
        };
      }

      return {
        color: "#111",
        weight: 2.2,
        fillColor: "#cfcfcf",
        fillOpacity: 1
      };
    }

    function refreshStyles() {
      if (!fillLayer) return;
      fillLayer.setStyle(styleFill);
    }

    function focusTarget() {
      if (!map || !currentTargetKey) return;
      const lyr = byKey.get(currentTargetKey);
      if (!lyr) return;

      try {
        const b = lyr.getBounds();
        if (b && b.isValid && b.isValid()) {
          map.fitBounds(b, { padding: [18, 18], animate: false });
        }
      } catch {}
    }

    function buildLayer(fc) {
      ensureMapReady();
      clearLayer();

      fillLayer = L.geoJSON(fc, {
        style: styleFill,
        onEachFeature: (feature, lyr) => {
          const p = feature.properties || {};
          const raw = getMunicipalityName(p);
          const key = normalize(raw);
          if (key) { byKey.set(key, lyr); keyToOfficial.set(key, raw); }
        }
      }).addTo(map);

      invalidateMapSizeHard();
    }

    // -----------------------------
    // Quiz mechanics
    // -----------------------------
    function computeXPForCorrect(elapsedSec, usedHint) {
      const t = Math.max(0, Math.min(GAME.TIME_LIMIT_SEC, elapsedSec));
      const timeFactor = (GAME.TIME_LIMIT_SEC - t) / GAME.TIME_LIMIT_SEC; // 0..1
      const bonus = Math.round(GAME.XP_TIME_BONUS_MAX * timeFactor);
      let xp = GAME.XP_BASE + bonus;
      if (usedHint) xp = Math.floor(xp * GAME.XP_HINT_MULT);
      return Math.max(0, xp);
    }

    function pickNewTargetKey() {
      if (playRemainingKeys.length === 0) playRemainingKeys = shuffle(playPoolKeys);
      return playRemainingKeys.pop() || "";
    }

    function prepareChoicesForRound() {
      const n = GAME.OPTIONS_COUNT;
      const forbid = new Set([currentTargetKey]);
      const wrong = sampleDistinct(playPoolKeys, n - 1, forbid);
      currentChoicesKeys = shuffle([currentTargetKey, ...wrong]);
    }

    function renderHUD() {
      sessionLine.textContent = `${Math.min(sessionIndex + 1, GAME.QUESTIONS_PER_SESSION)}/${GAME.QUESTIONS_PER_SESSION}`;
      btnHint.disabled = !(!awaitingAdvance && !sessionEnded) && true;
      btnHint.disabled = awaitingAdvance || sessionEnded || hintUsedThisRound;
    }

    function renderChoices() {
      choicesEl.innerHTML = "";

      for (const k of currentChoicesKeys) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "choiceBtn";
        b.textContent = keyToOfficial.get(k) || k;
        b.addEventListener("click", (e) => {
          e.stopPropagation();
          submitAnswerChoice(k);
        });
        choicesEl.appendChild(b);
      }
    }

    function setTapHint(show) {
      tapHint.classList.toggle("show", !!show);
    }

    function lockChoices(locked) {
      const btns = choicesEl.querySelectorAll("button.choiceBtn");
      btns.forEach(b => b.disabled = !!locked);
    }

    function markAnswerUI(chosenKey, isTimeout=false) {
      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      const correctKey = currentTargetKey;

      for (const b of btns) {
        const label = b.textContent;
        // map texto -> key (porque text pode repetir? aqui é seguro)
        let btnKey = "";
        for (const k of currentChoicesKeys) {
          if ((keyToOfficial.get(k) || k) === label) { btnKey = k; break; }
        }

        if (btnKey === correctKey) b.classList.add("correct");
        if (!isTimeout && btnKey === chosenKey && chosenKey !== correctKey) b.classList.add("wrong");
      }
    }

    function startTimer() {
      stopTimer();
      roundStartedAt = Date.now();

      timerHandle = setInterval(() => {
        if (awaitingAdvance || sessionEnded) return;

        const elapsed = (Date.now() - roundStartedAt) / 1000;
        const remain = Math.max(0, GAME.TIME_LIMIT_SEC - elapsed);

        timeLine.textContent = String(Math.ceil(remain));
        const pct = (remain / GAME.TIME_LIMIT_SEC) * 100;
        timerBar.style.width = `${pct}%`;

        if (remain <= 0) {
          stopTimer();
          onTimeout();
        }
      }, 100);
    }

    function onTimeout() {
      if (awaitingAdvance || sessionEnded) return;

      awaitingAdvance = true;
      lockChoices(true);

      setMsg(`Tempo! Era: ${currentTargetOfficial}`);
      markAnswerUI("__timeout__", true);
      setTapHint(true);
      renderHUD();

      // armar avanço por tap (evitar tap imediato)
      setTimeout(() => { /* noop */ }, 0);
    }

    function submitAnswerChoice(chosenKey) {
      if (awaitingAdvance || sessionEnded) return;

      stopTimer();
      awaitingAdvance = true;
      lockChoices(true);

      const elapsed = (Date.now() - roundStartedAt) / 1000;

      if (chosenKey === currentTargetKey) {
        sessionCorrect++;
        const xp = computeXPForCorrect(elapsed, hintUsedThisRound);
        sessionXP += xp;
        setMsg(`Certo! +${xp} XP`);
      } else {
        setMsg(`Errado. Era: ${currentTargetOfficial}`);
      }

      markAnswerUI(chosenKey, false);
      setTapHint(true);
      renderHUD();
    }

    function useHintRemoveTwo() {
      if (awaitingAdvance || sessionEnded) return;
      if (hintUsedThisRound) return;

      hintUsedThisRound = true;

      // Remover 2 erradas: esconder 2 botões errados
      const wrongKeys = currentChoicesKeys.filter(k => k !== currentTargetKey);
      const toHide = sampleDistinct(wrongKeys, 2);

      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      for (const b of btns) {
        const label = b.textContent;
        let btnKey = "";
        for (const k of currentChoicesKeys) {
          if ((keyToOfficial.get(k) || k) === label) { btnKey = k; break; }
        }
        if (toHide.includes(btnKey)) {
          b.classList.add("hidden");
          b.disabled = true;
        }
      }

      setMsg("Ajuda: removidas 2 opções (XP desta pergunta reduzido).");
      renderHUD();
    }

    function nextQuestionOrEnd() {
      if (sessionIndex >= GAME.QUESTIONS_PER_SESSION) {
        endSession();
        return;
      }
      nextRound();
    }

    function nextRound() {
      awaitingAdvance = false;
      hintUsedThisRound = false;
      setTapHint(false);
      setMsg("");

      currentTargetKey = pickNewTargetKey();
      currentTargetOfficial = keyToOfficial.get(currentTargetKey) || currentTargetKey;

      prepareChoicesForRound();
      renderHUD();
      renderChoices();
      lockChoices(false);

      // Atualiza mapa para mostrar só o município alvo e fazer fit
      refreshStyles();
      focusTarget();

      timeLine.textContent = String(GAME.TIME_LIMIT_SEC);
      timerBar.style.width = "100%";

      startTimer();
    }

    function endSession() {
      stopTimer();
      sessionEnded = true;
      awaitingAdvance = false;
      setTapHint(false);

      finalCorrect.textContent = `Corretas: ${sessionCorrect}/${GAME.QUESTIONS_PER_SESSION}`;
      finalXP.textContent = `XP ganho: ${sessionXP}`;
      finalOverlay.classList.add("show");
    }

    function resetSessionState() {
      stopTimer();
      awaitingAdvance = false;
      sessionEnded = false;

      sessionIndex = 0;
      sessionCorrect = 0;
      sessionXP = 0;

      hintUsedThisRound = false;
      currentTargetKey = "";
      currentTargetOfficial = "";
      currentChoicesKeys = [];

      setTapHint(false);
      setMsg("");
      timeLine.textContent = String(GAME.TIME_LIMIT_SEC);
      timerBar.style.width = "100%";
      finalOverlay.classList.remove("show");
    }

    // Tap-to-continue: 1 toque avança após responder/timeout
    document.getElementById("gameShell").addEventListener("click", () => {
      if (finalOverlay.classList.contains("show")) {
        // no overlay: volta ao menu
        backToMenu();
        return;
      }
      if (!awaitingAdvance || sessionEnded) return;

      sessionIndex++;
      nextQuestionOrEnd();
    });

    // -----------------------------
    // Start flow
    // -----------------------------
    async function loadDefaultDataset() {
      // Por agora: PT + 1 distrito default
      const url = FILES.concelhosPT(GAME.DEFAULT_DISTRICT);
      return await loadJSON(url);
    }

    async function startGameFlow() {
      document.body.classList.add("playing");
      showScreen(screenGame);

      ensureMapReady();
      invalidateMapSizeHard();

      resetSessionState();

      try {
        const fc = await loadDefaultDataset();
        buildLayer(fc);

        playPoolKeys = Array.from(byKey.keys());
        if (playPoolKeys.length < GAME.OPTIONS_COUNT) {
          throw new Error(`Poucas opções no dataset (${playPoolKeys.length}). Precisas de pelo menos ${GAME.OPTIONS_COUNT}.`);
        }
        playRemainingKeys = shuffle(playPoolKeys);

        // primeira pergunta
        nextRound();
      } catch (e) {
        console.error(e);
        setMsg("Erro a carregar dados. Confirma os GeoJSON em /data e o distrito default.");
      }
    }

    // -----------------------------
    // Back / Exit
    // -----------------------------
    function backToMenu() {
      resetSessionState();
      document.body.classList.remove("playing");
      showScreen(screenMenu);
    }

    btnExit.addEventListener("click", (e) => {
      e.stopPropagation();
      backToMenu();
    });

    btnHint.addEventListener("click", (e) => {
      e.stopPropagation();
      useHintRemoveTwo();
    });

    // Tap no overlay -> menu
    finalOverlay.addEventListener("click", (e) => {
      e.stopPropagation();
      backToMenu();
    });
  </script>
</body>
</html>


