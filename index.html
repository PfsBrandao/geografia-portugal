<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geografia PT — Jogo</title>
  <link rel="icon" href="data:,">

  <!-- PWA -->
  <link rel="manifest" href="/geografia-portugal/manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">

  <!-- iOS / Mobile (Add to Home Screen) -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="apple-touch-icon" href="/geografia-portugal/icons/icon-192.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 0; background:#fff; }
    .screen { display: none; height: 100vh; }
    .screen.active { display: block; }

    .menuWrap {
      min-height: 100dvh;
      background: #e8e9ea;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing: border-box;
    }
    .menuPhone {
      width: min(420px, 94vw);
      background: #0b0b0f;
      border-radius: 22px;
      padding: 16px;
      box-sizing: border-box;
      border: 2px solid rgba(0,0,0,.12);
    }
    .menuLogo {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      background: #000;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      margin-bottom: 14px;
      position: relative;
    }
    .menuLogo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      display:block;
    }
    .menuLogo .menuTitleOverlay{
      position:absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.55);
      color:#fff;
      font-weight: 900;
      font-size: 18px;
      text-align: center;
      display:none;
    }
    .menuLogo.hasTitle .menuTitleOverlay{ display:block; }

    .menuBtns { display:flex; flex-direction:column; gap: 12px; }
    .menuBtn {
      width: 100%;
      min-height: 64px;
      border-radius: 16px;
      border: 2px solid rgba(255,255,255,.15);
      background: #b1b2b5;
      font-size: 28px;
      font-weight: 900;
      cursor: pointer;
      user-select:none;
    }
    .menuBtn:active { transform: translateY(1px); }
    .menuBtn.disabled { opacity: .55; cursor: not-allowed; }
    .menuBtn.small { font-size: 26px; }

    :root {
      --bg: #0b0b0f;
      --panel: #efefef;
      --panelBorder: #bdbdbd;
    }

    html, body { height: 100%; }

    body.playing {
      background: var(--bg);
      height: 100dvh;
      overflow: hidden;
    }

    .gameShell {
      height: 100dvh;
      display: grid;
      gap: 6px;
      padding: 10px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      box-sizing: border-box;

      grid-template-rows:
        40px
        1fr
        64px
        clamp(200px, 28dvh, 280px);
    }

    .gameTop { display:flex; align-items:center; justify-content:flex-start; }
    .exitBtn{
      width: 44px;
      height: 34px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color:#fff;
      font-weight: 900;
      user-select:none;
      cursor:pointer;
    }

    .gameHUD {
      display: grid;
      grid-template-columns: 1fr 1fr 1.2fr;
      gap: 6px;
      align-items: stretch;
    }
    .hudBox {
      background: var(--panel);
      border: 2px solid var(--panelBorder);
      border-radius: 14px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      line-height: 1.05;
      padding: 6px;
      box-sizing: border-box;
      user-select: none;
    }
    .hudBox .k { font-size: 12px; color: #222; opacity: .75; }
    .hudBox .v { font-size: 22px; font-weight: 900; color: #111; }

    .hudBtn {
      border-radius: 14px;
      border: 2px solid #cfcfcf;
      font-size: 18px;
      font-weight: 900;
      cursor: pointer;
      background: linear-gradient(#33b5ff, #0c79d6);
      color: #071018;
      user-select: none;
    }
    .hudBtn:disabled { opacity: .6; cursor: not-allowed; }

    .gameStage {
      background: #eaeaea;
      border-radius: 18px;
      border: 3px solid var(--panelBorder);
      overflow: hidden;
      position: relative;
      min-height: 240px;
    }
    #map { height: 100%; width: 100%; background: #fff; }

    body.playing #map {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    body.playing .leaflet-control-zoom,
    body.playing .leaflet-control-attribution { display: none !important; }

    /* ==============
       INSET (AÇORES)
       ============== */
    .insetWrap{
      position:absolute;
      left: 10px;
      bottom: 10px;

      width: min(29vw, 154px);
      height: min(29vw, 154px);

      border-radius: 14px;
      border: 3px solid rgba(255,255,255,.85);
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      overflow:hidden;
      background:#fff;
      z-index: 40;
      display:none;
    }
    .insetWrap.show{ display:block; }
    #insetMap{ width:100%; height:100%; background:#fff; }
    body.playing #insetMap {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    .gameBottom {
      background: rgba(16,16,24,.95);
      border-radius: 18px;
      padding: 8px;
      box-sizing: border-box;
      color: #f2f2f2;
      overflow: hidden;
    }

    .choices {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      margin-top: 6px;
    }
    .choiceBtn {
      min-height: 44px;
      border-radius: 16px;
      border: 2px solid #cfcfcf;
      font-size: 14px;
      font-weight: 900;
      background: linear-gradient(#33b5ff, #0c79d6);
      color: #071018;
      white-space: normal;
      line-height: 1.08;
      cursor:pointer;
      user-select:none;
      padding: 10px 8px;
      -webkit-tap-highlight-color: transparent;
    }
    .choiceBtn:active { transform: translateY(1px); }
    .choiceBtn:disabled { opacity: 0.65; cursor: not-allowed; }
    .choiceBtn.hidden { visibility: hidden; }

    .choiceBtn.correct {
      background: #17c964 !important;
      border-color: rgba(0,0,0,.18) !important;
      color: #071018 !important;
    }
    .choiceBtn.wrong {
      background: #ff4d4f !important;
      border-color: rgba(0,0,0,.18) !important;
      color: #071018 !important;
    }

    /* =========================
       DIFICULDADE 4 (TEXTO + AUTOCOMPLETE)
       ========================= */
    .textAnswerBlock { margin-top: 6px; }
    .answerInput {
      width: 100%;
      min-height: 44px;
      border-radius: 16px;
      border: 2px solid #cfcfcf;
      font-size: 16px;
      font-weight: 900;
      padding: 10px 12px;
      box-sizing: border-box;
      outline: none;
    }
    .answerInput.correct {
      border-color: rgba(0,0,0,.18) !important;
      background: #17c964 !important;
      color: #071018 !important;
    }
    .answerInput.wrong {
      border-color: rgba(0,0,0,.18) !important;
      background: #ff4d4f !important;
      color: #071018 !important;
    }

    .answerDropdown {
      margin-top: 8px;
      border-radius: 16px;
      overflow: hidden;
      border: 2px solid rgba(255,255,255,.15);
      background: rgba(0,0,0,.25);
      display: none;
    }
    .answerDropdown.show { display: block; }
    .sugBtn {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border: 0;
      background: rgba(255,255,255,.08);
      color: #fff;
      font-weight: 900;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .sugBtn + .sugBtn { border-top: 1px solid rgba(255,255,255,.12); }
    .sugBtn:active { transform: translateY(1px); }
    .sugBtn:disabled { opacity: .6; cursor: not-allowed; }

    .answerFeedback {
      margin-top: 8px;
      font-size: 13px;
      font-weight: 900;
      color: #f2f2f2;
      opacity: .92;
      min-height: 16px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.58);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing:border-box;
      z-index: 50;
    }
    .overlay.show { display:flex; }
    .overlayCard {
      width: min(420px, 92vw);
      background: #efefef;
      border: 2px solid #bdbdbd;
      border-radius: 18px;
      padding: 16px;
      box-sizing:border-box;
      text-align:center;
    }
    .overlayCard .t { font-size: 24px; font-weight: 900; color: #111; margin: 0 0 10px; }
    .overlayCard .p { font-size: 18px; font-weight: 800; color: #111; margin: 8px 0; }
    .overlayCard .s { font-size: 13px; color: #333; margin-top: 10px; opacity: .85; }

    /* =========================
       OPTIONS TABLE SCREENS
       ========================= */
    .optWrap {
      min-height: 100dvh;
      background: #e8e9ea;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing: border-box;
    }
    .optPhone {
      width: min(520px, 94vw);
      background: #ffffff;
      border-radius: 22px;
      padding: 14px;
      box-sizing: border-box;
      border: 2px solid rgba(0,0,0,.12);
    }
    .optHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 6px 4px 10px;
      box-sizing:border-box;
    }
    .optTitle {
      font-weight: 900;
      font-size: 18px;
      color:#111;
    }
    .optMeta {
      font-size: 12px;
      color:#444;
    }
    .optHint {
      font-size: 12px;
      color:#444;
      margin: 0 4px 10px;
      line-height: 1.35;
    }
    .optTable {
      border: 1px solid #d6d6d6;
      border-radius: 14px;
      overflow: hidden;
    }
    .optRow {
      display:grid;
      grid-template-columns: 1.6fr repeat(4, 0.45fr);
      align-items:center;
      gap: 0;
      border-bottom: 1px solid #e7e7e7;
      min-height: 46px;
    }
    .optRow:last-child { border-bottom: none; }

    .optHead {
      background: #f3f3f3;
      font-weight: 900;
      color:#111;
      font-size: 12px;
      min-height: 44px;
    }
    .optCell {
      padding: 8px 10px;
      box-sizing:border-box;
      border-right: 1px solid #e7e7e7;
      height: 100%;
      display:flex;
      align-items:center;
    }
    .optRow .optCell:last-child { border-right: none; }

    .optName {
      font-weight: 800;
      font-size: 13px;
      color:#111;
      line-height: 1.15;
    }
    .optBadge {
      margin-left: 8px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #eee;
      color:#333;
      border: 1px solid #ddd;
    }

    .dotCell { justify-content:center; padding: 8px; }
    .dot {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid #999;
      background: #f6f6f6;
      cursor: pointer;
      display:inline-block;
      position: relative;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .dot.on {
      border-color: #2e7d32;
      background: #2ee66a;
      box-shadow: 0 0 0 2px rgba(46, 125, 50, 0.15);
    }

    .optFooter {
      display:flex;
      gap: 10px;
      justify-content:center;
      margin-top: 12px;
    }
    .optBtn {
      min-height: 52px;
      padding: 10px 14px;
      border-radius: 16px;
      border: 2px solid #cfcfcf;
      background: #b1b2b5;
      font-weight: 900;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
    }
    .optBtn.primary {
      background: linear-gradient(#33b5ff, #0c79d6);
      border-color: #cfcfcf;
      color:#071018;
    }

    @media (max-width: 420px) {
      .hudBox .v { font-size: 18px; }
      .hudBtn { font-size: 16px; }
      .choiceBtn { min-height: 42px; font-size: 13px; }
      .optPhone { padding: 12px; }
      .optRow { grid-template-columns: 1.7fr repeat(4, 0.42fr); }
      .dot { width: 16px; height: 16px; }

      .insetWrap{
        width: min(34vw, 160px);
        height: min(34vw, 160px);
      }
    }

    @media (min-width: 900px) {
      .gameShell { max-width: 1100px; margin: 0 auto; }
    }
  </style>
</head>

<body>
  <!-- MENU -->
  <div id="screenMenu" class="screen active">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo" aria-label="Geo-PT">
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
        </div>
        <div class="menuBtns">
          <button id="btnMenuPlay" class="menuBtn">Jogar</button>
          <button class="menuBtn disabled" disabled>Estudar</button>
          <button class="menuBtn disabled" disabled>Perfil</button>
          <button id="btnMenuOptions" class="menuBtn">Opções</button>
          <button id="btnMenuExit" class="menuBtn small">Sair</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SESSION LENGTH MENU -->
  <div id="screenSessionLen" class="screen">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo hasTitle" aria-label="Geo-PT">
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
          <div class="menuTitleOverlay">Quantas perguntas?</div>
        </div>
        <div class="menuBtns">
          <button class="menuBtn" data-qlen="10">10</button>
          <button class="menuBtn" data-qlen="25">25</button>
          <button class="menuBtn" data-qlen="50">50</button>
          <button class="menuBtn" data-qlen="100">100</button>
          <button id="btnSessionLenBack" class="menuBtn small">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- OPTIONS: MENU COM CATEGORIAS (mesmo aspeto do menu inicial) -->
  <div id="screenOptionsMenu" class="screen">
    <div class="menuWrap">
      <div class="menuPhone">
        <div class="menuLogo hasTitle" aria-label="Opções">
          <img alt="Geo-PT" src="/geografia-portugal/icons/icon-192.png" onerror="this.style.display='none'">
          <div class="menuTitleOverlay">Opções</div>
        </div>
        <div class="menuBtns">
          <button id="btnOptCatDistricts" class="menuBtn">Distritos</button>
          <button id="btnOptCatRivers" class="menuBtn disabled" disabled>Rios</button>
          <button id="btnOptCatRA" class="menuBtn">Regiões Autónomas</button>
          <button id="btnOptCatMountains" class="menuBtn disabled" disabled>Serras</button>
          <button id="btnOptCatFlags" class="menuBtn disabled" disabled>Bandeiras</button>
          <button id="btnOptMenuBack" class="menuBtn small">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- OPTIONS: DISTRITOS (tabela existente, só com distritos) -->
  <div id="screenOptionsDistricts" class="screen">
    <div class="optWrap">
      <div class="optPhone">
        <div class="optHeader">
          <div>
            <div class="optTitle">Distritos</div>
            <div class="optMeta" id="optSelectedCountDistricts">Selecionados: 0</div>
          </div>
          <button id="btnOptBackTopDistricts" class="exitBtn" type="button" style="color:#111; border-color:#ddd; background:#f3f3f3;">⟵</button>
        </div>

        <div class="optHint">
          Escolhe a dificuldade por distrito.
          Nível 1 = 4 opções, Nível 2 = 6 opções, Nível 3 = 8 opções.
          Nível 4 fica disponível para escolher, mas ainda não está implementado no jogo.
        </div>

        <div class="optTable" id="optTableDistricts"></div>

        <div class="optFooter">
          <button id="btnOptResetDistricts" class="optBtn" type="button">Reset</button>
          <button id="btnOptSaveDistricts" class="optBtn primary" type="button">Guardar</button>
          <button id="btnOptBackDistricts" class="optBtn" type="button">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- OPTIONS: REGIÕES AUTÓNOMAS (tabela com Açores + Madeira) -->
  <div id="screenOptionsRA" class="screen">
    <div class="optWrap">
      <div class="optPhone">
        <div class="optHeader">
          <div>
            <div class="optTitle">Regiões Autónomas</div>
            <div class="optMeta" id="optSelectedCountRA">Selecionados: 0</div>
          </div>
          <button id="btnOptBackTopRA" class="exitBtn" type="button" style="color:#111; border-color:#ddd; background:#f3f3f3;">⟵</button>
        </div>

        <div class="optHint">
          Escolhe a dificuldade por região.
          Nível 1 = 4 opções, Nível 2 = 6 opções, Nível 3 = 8 opções.
          Nível 4 fica disponível para escolher, mas ainda não está implementado no jogo.
        </div>

        <div class="optTable" id="optTableRA"></div>

        <div class="optFooter">
          <button id="btnOptResetRA" class="optBtn" type="button">Reset</button>
          <button id="btnOptSaveRA" class="optBtn primary" type="button">Guardar</button>
          <button id="btnOptBackRA" class="optBtn" type="button">Voltar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="screenLoading" class="screen">
    <div class="menuWrap">
      <div class="menuPhone" style="background:#fff;">
        <div style="font-weight:900; font-size:20px; margin-bottom:10px;">A carregar…</div>
        <div id="loadingText" style="font-size:13px; color:#444;">—</div>
        <div style="margin-top:12px; height:10px; background:#eee; border-radius:999px; overflow:hidden; border:1px solid #e6e6e6;">
          <div id="loadingBar" style="height:100%; width:0%; background:#111; transition:width 150ms linear;"></div>
        </div>
        <div id="loadingPct" style="margin-top:10px; font-size:13px; color:#444;">0%</div>
      </div>
    </div>
  </div>

  <!-- GAME -->
  <div id="screenGame" class="screen">
    <div class="gameShell" id="gameShell">
      <div class="gameTop">
        <button id="btnExit" class="exitBtn" type="button">⟵</button>
      </div>

      <div class="gameStage">
        <div id="map"></div>

        <!-- INSET (AÇORES) -->
        <div id="insetWrap" class="insetWrap" aria-hidden="true">
          <div id="insetMap"></div>
        </div>

        <div id="finalOverlay" class="overlay" role="dialog" aria-modal="true">
          <div class="overlayCard">
            <div class="t">Fim!</div>
            <div class="p" id="finalCorrect">Corretas: 0/10</div>
            <div class="p" id="finalXP">XP ganho: 0</div>
            <div class="s">Toca para voltar ao menu</div>
          </div>
        </div>
      </div>

      <div class="gameHUD">
        <div class="hudBox">
          <div class="k">Tempo</div>
          <div class="v"><span id="timeLine">60</span></div>
        </div>

        <div class="hudBox">
          <div class="k">Questão</div>
          <div class="v"><span id="sessionLine">1/10</span></div>
        </div>

        <button class="hudBtn" id="btnHint" type="button">Ajuda</button>
      </div>

      <div class="gameBottom">
        <div id="choicesBlock">
          <div class="choices" id="choices"></div>
        </div>

        <!-- DIFICULDADE 4 -->
        <div id="textAnswerBlock" class="textAnswerBlock" style="display:none;">
          <input
            id="answerInput"
            class="answerInput"
            type="text"
            placeholder="Escreve o concelho…"
            autocomplete="off"
            autocapitalize="words"
            spellcheck="false"
            enterkeyhint="done"
          >
          <div id="answerDropdown" class="answerDropdown" role="listbox" aria-label="Sugestões"></div>
          <div id="textAnswerFeedback" class="answerFeedback"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/geografia-portugal/sw.js").catch(() => {});
    }

    const BASE = "/geografia-portugal/";
    const FILES = {
      concelhosPT: (districtSlug) => `${BASE}data/concelhos_${districtSlug}.geojson`,
      concelhosAZ: `${BASE}data/concelhos_acores.geojson`,
      concelhosMD: `${BASE}data/concelhos_madeira.geojson`,
    };

    const DISTRICTS_PT = [
      ["Aveiro","aveiro"], ["Beja","beja"], ["Braga","braga"], ["Bragança","braganca"],
      ["Castelo Branco","castelo_branco"], ["Coimbra","coimbra"], ["Évora","evora"],
      ["Faro","faro"], ["Guarda","guarda"], ["Leiria","leiria"], ["Lisboa","lisboa"],
      ["Portalegre","portalegre"], ["Porto","porto"], ["Santarém","santarem"],
      ["Setúbal","setubal"], ["Viana do Castelo","viana_do_castelo"],
      ["Vila Real","vila_real"], ["Viseu","viseu"]
    ];

    function getAllPacks() {
      const arr = DISTRICTS_PT.map(([name, slug]) => ({ id:`pt:${slug}`, label:`Distrito — ${name}`, region:"pt", slug }));
      arr.push({ id:"az", label:"Região — Açores", region:"az", slug:"acores" });
      arr.push({ id:"md", label:"Região — Madeira", region:"md", slug:"madeira" });
      return arr;
    }

    const PLAY = {
      TIME_LIMIT_SEC: 60,
      optionsByPackLevel: (lvl) => (lvl === 1 ? 4 : lvl === 2 ? 6 : 8),
      difficultyMultByPackLevel: (lvl) => (lvl === 1 ? 1.00 : lvl === 2 ? 1.18 : lvl === 3 ? 1.38 : 1.65), // lvl4
      hintMult: 0.60,
    };

    let QUESTIONS_PER_SESSION = 10;

    function normalize(s) {
      return (s || "").trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\s+/g, " ");
    }
    function pickProp(props, keys) {
      for (const k of keys) {
        if (props && props[k] != null && String(props[k]).trim() !== "") return String(props[k]);
      }
      return "";
    }
    function getMunicipalityName(props) {
      return pickProp(props, ["Concelho","CONCELHO","MUNICIPIO","Municipio","MUNICÍPIO","municipio","NAME_2","NAME2","NAME"]);
    }
    function getIslandName(props) {
      return pickProp(props, ["ILHA","Ilha","ilha","ILHA_1","Ilha_1","ISLAND","Island","island"]);
    }
    function getMunicipalityKey(props) {
      const code = pickProp(props, [
        "DICOFRE","dicofre",
        "CODIGO","codigo",
        "COD_MUN","cod_mun",
        "ID","id",
        "OBJECTID","objectid"
      ]);
      if (code) return `id:${normalize(code)}`;
      const name = getMunicipalityName(props);
      return `nm:${normalize(name)}`;
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function sampleDistinct(arr, n, forbidSet) {
      const pool = [];
      for (const x of arr) {
        if (forbidSet && forbidSet.has(x)) continue;
        pool.push(x);
      }
      const s = shuffle(pool);
      return s.slice(0, Math.min(n, s.length));
    }

    function assertGeoJSONLooksLikeLonLat(fc, sampleN = 3) {
      const coords = [];
      function walkGeom(g) {
        if (!g) return;
        const t = g.type;
        const c = g.coordinates;
        if (!t || !c) return;
        if (t === "Point") coords.push(c);
        else if (t === "MultiPoint" || t === "LineString") c.forEach(p => coords.push(p));
        else if (t === "MultiLineString") c.flat().forEach(p => coords.push(p));
        else if (t === "Polygon") c.flat().forEach(p => coords.push(p));
        else if (t === "MultiPolygon") c.flat(2).forEach(p => coords.push(p));
        else if (t === "GeometryCollection" && Array.isArray(g.geometries)) g.geometries.forEach(walkGeom);
      }
      for (const f of (fc.features || [])) {
        walkGeom(f.geometry);
        if (coords.length >= sampleN) break;
      }
      if (coords.length === 0) return { ok: false, reason: "GeoJSON sem coordenadas." };
      const [lon, lat] = coords[0] || [];
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) return { ok: false, reason: "Coordenadas inválidas (NaN/null)." };
      const inLonLatRange = (Math.abs(lon) <= 180 && Math.abs(lat) <= 90);
      if (!inLonLatRange) return { ok: false, reason: `CRS errado? Ex: [${lon}, ${lat}]` };
      return { ok: true, reason: "ok" };
    }

    function safeZoomToBounds(m, b, fitOpts = {}, padDeg = 0.25) {
      if (!m || !b || !b.isValid || !b.isValid()) return null;
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();
      const dLat = Math.abs(ne.lat - sw.lat);
      const dLng = Math.abs(ne.lng - sw.lng);

      if (dLat < 0.01 && dLng < 0.01) {
        const c = b.getCenter();
        const expanded = L.latLngBounds(
          [c.lat - padDeg, c.lng - padDeg],
          [c.lat + padDeg, c.lng + padDeg]
        );
        m.fitBounds(expanded, fitOpts);
        return expanded;
      }
      m.fitBounds(b, fitOpts);
      return b;
    }

    function toNum(x) {
      if (typeof x === "number") return x;
      if (typeof x !== "string") return Number(x);
      const s = x.trim().replace(",", ".");
      return Number(s);
    }
    function coordPairOk(pair) {
      if (!Array.isArray(pair) || pair.length < 2) return false;
      const lon = toNum(pair[0]);
      const lat = toNum(pair[1]);
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) return false;
      if (Math.abs(lon) > 180 || Math.abs(lat) > 90) return false;
      return true;
    }
    function geometryHasOnlyValidCoords(geom) {
      if (!geom) return false;
      const t = geom.type;
      const c = geom.coordinates;
      if (t === "Point") return coordPairOk(c);
      if (t === "MultiPoint" || t === "LineString") return Array.isArray(c) && c.every(coordPairOk);
      if (t === "MultiLineString" || t === "Polygon") return Array.isArray(c) && c.every(line => Array.isArray(line) && line.every(coordPairOk));
      if (t === "MultiPolygon") return Array.isArray(c) && c.every(poly => Array.isArray(poly) && poly.every(ring => Array.isArray(ring) && ring.every(coordPairOk)));
      if (t === "GeometryCollection") return Array.isArray(geom.geometries) && geom.geometries.every(geometryHasOnlyValidCoords);
      return false;
    }
    function sanitizeFeatureCollection(fc) {
      const features = Array.isArray(fc?.features) ? fc.features : [];
      const kept = [];
      const dropped = [];
      for (const f of features) {
        const props = f?.properties || {};
        const name = getMunicipalityName(props) || "(sem nome)";
        if (geometryHasOnlyValidCoords(f?.geometry)) kept.push(f);
        else dropped.push(name);
      }
      if (dropped.length) console.warn("Concelhos removidos por coordenadas estranhas:", dropped);
      return { cleaned: { ...fc, features: kept }, dropped };
    }

    const cache = new Map();
    async function loadJSON(url) {
      if (cache.has(url)) return cache.get(url);
      const p = fetch(url)
        .then(async (r) => {
          if (!r.ok) throw new Error(`Falha a carregar ${url} (HTTP ${r.status})`);
          const txt = await r.text();
          const clean = (txt.charCodeAt(0) === 0xFEFF) ? txt.slice(1) : txt;
          return JSON.parse(clean);
        })
        .catch((err) => {
          cache.delete(url);
          throw err;
        });
      cache.set(url, p);
      return p;
    }

    // SCREENS
    const screenMenu = document.getElementById("screenMenu");
    const screenSessionLen = document.getElementById("screenSessionLen");
    const screenOptionsMenu = document.getElementById("screenOptionsMenu");
    const screenOptionsDistricts = document.getElementById("screenOptionsDistricts");
    const screenOptionsRA = document.getElementById("screenOptionsRA");
    const screenLoading = document.getElementById("screenLoading");
    const screenGame = document.getElementById("screenGame");

    const loadingText = document.getElementById("loadingText");
    const loadingBar = document.getElementById("loadingBar");
    const loadingPct = document.getElementById("loadingPct");

    function showScreen(el) {
      const all = [screenMenu, screenSessionLen, screenOptionsMenu, screenOptionsDistricts, screenOptionsRA, screenLoading, screenGame];
      for (const s of all) s.classList.remove("active");
      el.classList.add("active");
    }
    function setLoading(step, pct) {
      loadingText.textContent = step;
      loadingBar.style.width = `${pct}%`;
      loadingPct.textContent = `${pct}%`;
    }

    // MENU BUTTONS
    const btnMenuPlay = document.getElementById("btnMenuPlay");
    const btnMenuOptions = document.getElementById("btnMenuOptions");
    const btnMenuExit = document.getElementById("btnMenuExit");

    btnMenuExit.addEventListener("click", () => {
      try { window.close(); } catch {}
      alert("Para sair, fecha o separador / a app (PWA).");
    });

    btnMenuPlay.addEventListener("click", () => showScreen(screenSessionLen));
    document.getElementById("btnSessionLenBack").addEventListener("click", () => showScreen(screenMenu));

    screenSessionLen.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-qlen]");
      if (!btn) return;
      const n = Number(btn.dataset.qlen || 10);
      QUESTIONS_PER_SESSION = ([10,25,50,100].includes(n) ? n : 10);
      startGame();
    });

    // OPTIONS MENU OPEN/CLOSE
    btnMenuOptions.addEventListener("click", () => {
      showScreen(screenOptionsMenu);
    });
    document.getElementById("btnOptMenuBack").addEventListener("click", () => showScreen(screenMenu));

    // OPTIONS CATEGORY BUTTONS
    document.getElementById("btnOptCatDistricts").addEventListener("click", () => openOptionsDistricts());
    document.getElementById("btnOptCatRA").addEventListener("click", () => openOptionsRA());

    // GAME UI
    const btnExit = document.getElementById("btnExit");
    const timeLine = document.getElementById("timeLine");
    const sessionLine = document.getElementById("sessionLine");
    const btnHint = document.getElementById("btnHint");
    const choicesEl = document.getElementById("choices");
    const finalOverlay = document.getElementById("finalOverlay");
    const finalCorrect = document.getElementById("finalCorrect");
    const finalXP = document.getElementById("finalXP");
    const insetWrap = document.getElementById("insetWrap");

    // Dificuldade 4 UI
    const choicesBlock = document.getElementById("choicesBlock");
    const textAnswerBlock = document.getElementById("textAnswerBlock");
    const answerInput = document.getElementById("answerInput");
    const answerDropdown = document.getElementById("answerDropdown");
    const textAnswerFeedback = document.getElementById("textAnswerFeedback");

    /* =========================
       OPTIONS STATE (mantém igual)
       ========================= */
    const OPT_KEY = "geoPT_options_v1";

    function defaultOptions() { return { levels: { "pt:porto": 3 } }; }

    function loadOptions() {
      try {
        const raw = localStorage.getItem(OPT_KEY);
        if (!raw) return defaultOptions();
        const o = JSON.parse(raw);
        if (!o || typeof o !== "object") return defaultOptions();
        if (!o.levels || typeof o.levels !== "object") o.levels = {};
        return o;
      } catch {
        return defaultOptions();
      }
    }
    function saveOptions(o) { localStorage.setItem(OPT_KEY, JSON.stringify(o)); }

    function getSelectedPacksFromOptions(o) {
      const packs = getAllPacks();
      const selected = [];
      for (const p of packs) {
        const lvl = Number(o.levels?.[p.id] || 0);
        if (lvl >= 1 && lvl <= 4) selected.push({ ...p, level: lvl });
      }
      return selected;
    }

    let optionsDraft = loadOptions();

    function countSelectedForFilter(filterFn) {
      const packs = getAllPacks().filter(filterFn);
      let c = 0;
      for (const p of packs) {
        const lvl = Number(optionsDraft.levels?.[p.id] || 0);
        if (lvl >= 1 && lvl <= 4) c++;
      }
      return c;
    }

    // Render genérico de tabela por "lista de packs"
    function renderOptionsTableInto(optTableEl, selectedCountEl, packs) {
      optTableEl.innerHTML = "";

      const head = document.createElement("div");
      head.className = "optRow optHead";
      head.innerHTML = `
        <div class="optCell">Zona</div>
        <div class="optCell dotCell">1</div>
        <div class="optCell dotCell">2</div>
        <div class="optCell dotCell">3</div>
        <div class="optCell dotCell">4</div>
      `;
      optTableEl.appendChild(head);

      for (const p of packs) {
        const row = document.createElement("div");
        row.className = "optRow";
        row.dataset.id = p.id;

        const nameCell = document.createElement("div");
        nameCell.className = "optCell";
        const lvl = Number(optionsDraft.levels?.[p.id] || 0);
        const badge = (lvl === 4) ? `<span class="optBadge">em breve</span>` : "";
        nameCell.innerHTML = `<div class="optName">${p.label}${badge}</div>`;
        row.appendChild(nameCell);

        for (let L = 1; L <= 4; L++) {
          const cell = document.createElement("div");
          cell.className = "optCell dotCell";

          const dot = document.createElement("span");
          dot.className = "dot" + (lvl === L ? " on" : "");
          dot.title = `Nível ${L}`;

          dot.addEventListener("click", () => {
            const cur = Number(optionsDraft.levels?.[p.id] || 0);
            if (cur === L) delete optionsDraft.levels[p.id];
            else optionsDraft.levels[p.id] = L;
            // re-render rápido
            renderOptionsTableInto(optTableEl, selectedCountEl, packs);
          });

          cell.appendChild(dot);
          row.appendChild(cell);
        }

        optTableEl.appendChild(row);
      }

      // meta selecionados
      let sel = 0;
      for (const p of packs) {
        const lvl = Number(optionsDraft.levels?.[p.id] || 0);
        if (lvl >= 1 && lvl <= 4) sel++;
      }
      selectedCountEl.textContent = `Selecionados: ${sel}`;
    }

    // DISTRITOS SCREEN
    const optTableDistricts = document.getElementById("optTableDistricts");
    const optSelectedCountDistricts = document.getElementById("optSelectedCountDistricts");
    const btnOptBackDistricts = document.getElementById("btnOptBackDistricts");
    const btnOptBackTopDistricts = document.getElementById("btnOptBackTopDistricts");
    const btnOptSaveDistricts = document.getElementById("btnOptSaveDistricts");
    const btnOptResetDistricts = document.getElementById("btnOptResetDistricts");

    function openOptionsDistricts() {
      optionsDraft = loadOptions();
      const packs = getAllPacks().filter(p => p.region === "pt");
      renderOptionsTableInto(optTableDistricts, optSelectedCountDistricts, packs);
      showScreen(screenOptionsDistricts);
    }
    function closeDistrictsToOptionsMenu() { showScreen(screenOptionsMenu); }

    btnOptBackDistricts.addEventListener("click", () => closeDistrictsToOptionsMenu());
    btnOptBackTopDistricts.addEventListener("click", () => closeDistrictsToOptionsMenu());

    btnOptResetDistricts.addEventListener("click", () => {
      // reset só dos distritos (mantém o que houver nas RAs)
      const base = loadOptions();
      optionsDraft = base;
      const packs = getAllPacks().filter(p => p.region === "pt");
      for (const p of packs) delete optionsDraft.levels[p.id];
      // mantém pelo menos porto=3, como no default, se quiseres:
      optionsDraft.levels["pt:porto"] = 3;
      renderOptionsTableInto(optTableDistricts, optSelectedCountDistricts, packs);
    });

    btnOptSaveDistricts.addEventListener("click", () => {
      // validação: pelo menos 1 pack selecionado no total (como antes)
      const selected = getSelectedPacksFromOptions(optionsDraft);
      if (selected.length === 0) {
        alert("Seleciona pelo menos 1 distrito/região para jogar.");
        return;
      }
      saveOptions(optionsDraft);
      closeDistrictsToOptionsMenu();
    });

    // REGIÕES AUTÓNOMAS SCREEN
    const optTableRA = document.getElementById("optTableRA");
    const optSelectedCountRA = document.getElementById("optSelectedCountRA");
    const btnOptBackRA = document.getElementById("btnOptBackRA");
    const btnOptBackTopRA = document.getElementById("btnOptBackTopRA");
    const btnOptSaveRA = document.getElementById("btnOptSaveRA");
    const btnOptResetRA = document.getElementById("btnOptResetRA");

    function openOptionsRA() {
      optionsDraft = loadOptions();
      const packs = getAllPacks().filter(p => (p.region === "az" || p.region === "md"));
      renderOptionsTableInto(optTableRA, optSelectedCountRA, packs);
      showScreen(screenOptionsRA);
    }
    function closeRAToOptionsMenu() { showScreen(screenOptionsMenu); }

    btnOptBackRA.addEventListener("click", () => closeRAToOptionsMenu());
    btnOptBackTopRA.addEventListener("click", () => closeRAToOptionsMenu());

    btnOptResetRA.addEventListener("click", () => {
      // reset só das RAs
      optionsDraft = loadOptions();
      const packs = getAllPacks().filter(p => (p.region === "az" || p.region === "md"));
      for (const p of packs) delete optionsDraft.levels[p.id];
      renderOptionsTableInto(optTableRA, optSelectedCountRA, packs);
    });

    btnOptSaveRA.addEventListener("click", () => {
      const selected = getSelectedPacksFromOptions(optionsDraft);
      if (selected.length === 0) {
        alert("Seleciona pelo menos 1 distrito/região para jogar.");
        return;
      }
      saveOptions(optionsDraft);
      closeRAToOptionsMenu();
    });

    /* =========================
       LEAFLET
       ========================= */
    let map = null;
    let fillLayer = null;

    let insetMap = null;
    let insetLayer = null;
    let insetRect = null;

    let lastCleanedGeoJSON = null;
    let insetPrimed = false;

    let byKey = new Map();
    let keyToOfficial = new Map();

    let keyToIsland = new Map();
    let islandToBounds = new Map();

    let keyToBounds = new Map();

    function ensureMapReady() {
      if (map) return;
      map = L.map("map", {
        zoomControl: false,
        attributionControl: false,
        zoomAnimation: false,
        fadeAnimation: false,
        markerZoomAnimation: false
      });
      map.setView([39.5, -8.0], 7);
    }

    function ensureInsetReady() {
      if (insetMap) return;
      insetMap = L.map("insetMap", {
        zoomControl: false,
        attributionControl: false,
        dragging: false,
        touchZoom: false,
        doubleClickZoom: false,
        scrollWheelZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomAnimation: false,
        fadeAnimation: false,
        markerZoomAnimation: false
      });
      insetMap.setView([39.5, -8.0], 7);
    }

    function invalidateMapSizeHard() {
      if (!map) return;
      requestAnimationFrame(() => {
        try { map.invalidateSize(true); } catch {}
        requestAnimationFrame(() => {
          try { map.invalidateSize(true); } catch {}
        });
      });
    }

    function invalidateInsetSizeHard() {
      if (!insetMap) return;
      requestAnimationFrame(() => {
        try { insetMap.invalidateSize(true); } catch {}
        requestAnimationFrame(() => {
          try { insetMap.invalidateSize(true); } catch {}
        });
      });
    }

    function afterNextPaint(fn) { requestAnimationFrame(() => requestAnimationFrame(fn)); }

    function setMapInteractive(enabled) {
      if (!map) return;
      const m = map;
      if (enabled) {
        m.dragging.enable();
        m.touchZoom.enable();
        m.doubleClickZoom.enable();
        m.scrollWheelZoom.enable();
        m.boxZoom.enable();
        m.keyboard.enable();
        if (m.tap) m.tap.enable();
      } else {
        m.dragging.disable();
        m.touchZoom.disable();
        m.doubleClickZoom.disable();
        m.scrollWheelZoom.disable();
        m.boxZoom.disable();
        m.keyboard.disable();
        if (m.tap) m.tap.disable();
      }
    }

    function clearLayer() {
      if (fillLayer) fillLayer.remove();
      fillLayer = null;

      if (insetLayer) insetLayer.remove();
      insetLayer = null;

      if (insetRect) insetRect.remove();
      insetRect = null;

      lastCleanedGeoJSON = null;

      byKey.clear();
      keyToOfficial.clear();

      keyToIsland.clear();
      islandToBounds.clear();
      keyToBounds.clear();
    }

    /* =========================
       GAME STATE
       ========================= */
    let playActive = false;

    let selectedPacks = [];
    let currentPack = null;

    let playPackLevel = 3;
    let playPoolKeys = [];
    let playPoolEntries = []; // [{key, name, norm}] ordenado alfabeticamente
    let playRemainingKeys = [];
    let currentTargetKey = "";
    let currentChoicesKeys = [];
    let hintUsedThisRound = false;

    let roundStartedAt = 0;
    let timerHandle = null;

    let sessionIndex = 0;
    let sessionCorrect = 0;
    let sessionWrong = 0;
    let sessionXP = 0;

    let awaitingTap = false;
    let inputBlockedUntil = 0;
    let transitioning = false;

    // "airbag" para o tap de avançar não marcar input/opções da ronda seguinte
    let suppressChoiceUntil = 0;

    function stopTimer() {
      if (timerHandle) clearInterval(timerHandle);
      timerHandle = null;
    }

    function lockChoices(locked) {
      const btns = choicesEl.querySelectorAll("button.choiceBtn");
      btns.forEach(b => b.disabled = !!locked);
    }

    function setAnswerModeText(enabled) {
      choicesBlock.style.display = enabled ? "none" : "block";
      textAnswerBlock.style.display = enabled ? "block" : "none";
    }

    function hideDropdown() {
      answerDropdown.classList.remove("show");
      answerDropdown.innerHTML = "";
    }

    function lockTextAnswer(locked) {
      answerInput.disabled = !!locked;
      const btns = answerDropdown.querySelectorAll("button");
      btns.forEach(b => b.disabled = !!locked);
    }

    function clearTextAnswerUI() {
      answerInput.value = "";
      answerInput.classList.remove("correct", "wrong");
      textAnswerFeedback.textContent = "";
      hideDropdown();
    }

    function styleFill(feature) {
      const key = getMunicipalityKey(feature.properties || {});
      if (playActive) {
        const isTarget = (key && key === currentTargetKey);
        return { color:"#000", weight: isTarget ? 2.0 : 1.1, fillColor: isTarget ? "#c00" : "#fff", fillOpacity: 1 };
      }
      return { color:"#000", weight: 1.1, fillColor:"#fff", fillOpacity: 1 };
    }

    function refreshStyles() {
      if (fillLayer) fillLayer.setStyle(styleFill);
      if (insetLayer) insetLayer.setStyle(styleFill);
    }

    function buildLayer(fc) {
      ensureMapReady();
      clearLayer();

      const { cleaned } = sanitizeFeatureCollection(fc);
      if (!cleaned.features || cleaned.features.length === 0) {
        throw new Error("GeoJSON sem features válidas (após limpeza).");
      }

      lastCleanedGeoJSON = cleaned;

      fillLayer = L.geoJSON(cleaned, {
        style: styleFill,
        onEachFeature: (feature, layer) => {
          const raw = getMunicipalityName(feature.properties || {});
          const key = getMunicipalityKey(feature.properties || {});
          if (!key) return;

          byKey.set(key, true);
          keyToOfficial.set(key, raw);

          try {
            const bKey = layer.getBounds?.();
            if (bKey && bKey.isValid && bKey.isValid()) keyToBounds.set(key, bKey);
          } catch {}

          const ilha = getIslandName(feature.properties || {});
          if (ilha) {
            keyToIsland.set(key, ilha);
            try {
              const b = layer.getBounds?.();
              if (b && b.isValid && b.isValid()) {
                const cur = islandToBounds.get(ilha);
                islandToBounds.set(ilha, cur ? cur.extend(b) : b);
              }
            } catch {}
          }
        }
      }).addTo(map);

      invalidateMapSizeHard();

      try {
        const b = fillLayer.getBounds();
        if (b && b.isValid && b.isValid()) {
          map.fitBounds(b, { padding: [8, 8], animate: false });
        }
      } catch {}
    }

    async function loadConcelhosFCForPack(pack) {
      setLoading(`A carregar: ${pack.label}`, 55);

      if (pack.region === "pt") {
        const url = FILES.concelhosPT(pack.slug);
        const fc = await loadJSON(url);
        const check = assertGeoJSONLooksLikeLonLat(fc);
        if (!check.ok) throw new Error(`GeoJSON inválido: ${check.reason} (${url})`);
        return fc;
      }

      const url = (pack.region === "az") ? FILES.concelhosAZ : FILES.concelhosMD;
      const fc = await loadJSON(url);
      const check = assertGeoJSONLooksLikeLonLat(fc);
      if (!check.ok) throw new Error(`GeoJSON inválido: ${check.reason} (${url})`);
      return fc;
    }

    function startTimer() {
      stopTimer();
      roundStartedAt = Date.now();

      timerHandle = setInterval(() => {
        if (!playActive) return;
        if (awaitingTap) return;
        if (transitioning) return;

        const elapsed = (Date.now() - roundStartedAt) / 1000;
        const remain = Math.max(0, PLAY.TIME_LIMIT_SEC - elapsed);

        timeLine.textContent = String(Math.ceil(remain));

        if (remain <= 0) {
          stopTimer();
          onTimeout();
        }
      }, 100);
    }

    function onTimeout() {
      if (!playActive || awaitingTap || transitioning) return;

      sessionWrong++;
      sessionIndex++;

      awaitingTap = true;
      inputBlockedUntil = Date.now() + 250;

      // feedback/lock para modo texto também
      if (playPackLevel === 4) {
        lockTextAnswer(true);
        hideDropdown();
        answerInput.classList.add("wrong");
        const correctName = keyToOfficial.get(currentTargetKey) || "";
        textAnswerFeedback.textContent = correctName ? `Tempo! Era: ${correctName}` : "Tempo!";
      } else {
        revealCorrectAndWrong("__timeout__");
        lockChoices(true);
      }

      renderHUD();
    }

    function computeXPForCorrect(elapsedSec, packLevel, usedHint) {
      const t = Math.max(0, Math.min(PLAY.TIME_LIMIT_SEC, elapsedSec));
      const timeFactor = (PLAY.TIME_LIMIT_SEC - t) / PLAY.TIME_LIMIT_SEC;
      const base = 10;
      const bonus = Math.round(40 * timeFactor);
      let xp = base + bonus;
      xp = xp * PLAY.difficultyMultByPackLevel(packLevel);
      if (usedHint) xp = xp * PLAY.hintMult;
      return Math.max(0, Math.floor(xp));
    }

    function pickPackForRound() {
      return selectedPacks[Math.floor(Math.random() * selectedPacks.length)];
    }

    function pickNewTargetKey() {
      if (playRemainingKeys.length === 0) playRemainingKeys = shuffle(playPoolKeys);
      return playRemainingKeys.pop() || "";
    }

    function prepareChoicesForRound() {
      if (playPackLevel === 4) {
        currentChoicesKeys = [];
        return;
      }
      const n = PLAY.optionsByPackLevel(playPackLevel);
      const forbid = new Set([currentTargetKey]);
      const wrong = sampleDistinct(playPoolKeys, n - 1, forbid);
      currentChoicesKeys = shuffle([currentTargetKey, ...wrong]);
    }

    function renderHUD() {
      const shown = awaitingTap
        ? Math.min(sessionIndex, QUESTIONS_PER_SESSION)
        : Math.min(sessionIndex + 1, QUESTIONS_PER_SESSION);

      sessionLine.textContent = `${shown}/${QUESTIONS_PER_SESSION}`;
      btnHint.disabled = (!playActive) || awaitingTap || hintUsedThisRound || transitioning;
    }

    function renderChoices() {
      choicesEl.innerHTML = "";
      for (const k of currentChoicesKeys) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "choiceBtn";
        b.dataset.key = k;
        b.textContent = keyToOfficial.get(k) || k;

        b.addEventListener("click", (e) => {
          e.stopPropagation();
          if (Date.now() < suppressChoiceUntil) return;
          if (Date.now() < inputBlockedUntil) return;
          if (transitioning) return;
          submitAnswerChoice(k);
        });

        choicesEl.appendChild(b);
      }
    }

    function revealCorrectAndWrong(chosenKey) {
      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      for (const b of btns) {
        const k = b.dataset.key || "";
        if (k === currentTargetKey) b.classList.add("correct");
        if (chosenKey !== "__timeout__" && k === chosenKey && chosenKey !== currentTargetKey) b.classList.add("wrong");
      }
    }

    function localeCmpPT(a, b) {
      return String(a).localeCompare(String(b), "pt", { sensitivity: "base" });
    }

    function rebuildPlayPoolEntries() {
      playPoolEntries = Array.from(keyToOfficial.entries()).map(([key, name]) => ({
        key,
        name,
        norm: normalize(name)
      }));
      playPoolEntries.sort((x, y) => localeCmpPT(x.name, y.name));
    }

    async function ensurePackLoaded(pack) {
      if (currentPack && currentPack.id === pack.id) {
        playPackLevel = pack.level;
        return;
      }

      transitioning = true;
      lockChoices(true);
      lockTextAnswer(true);
      stopTimer();

      currentPack = pack;
      playPackLevel = pack.level;

      setLoading(`A preparar: ${pack.label}`, 65);
      const fc = await loadConcelhosFCForPack(pack);

      setLoading("A desenhar…", 85);
      buildLayer(fc);

      invalidateMapSizeHard();
      setTimeout(invalidateMapSizeHard, 200);

      playPoolKeys = Array.from(keyToOfficial.keys());
      rebuildPlayPoolEntries();
      playRemainingKeys = shuffle(playPoolKeys);

      insetPrimed = false;
      if (insetLayer) { insetLayer.remove(); insetLayer = null; }
      if (insetRect) { insetRect.remove(); insetRect = null; }

      transitioning = false;
    }

    function updateAzoresInsetForCurrentTarget() {
      if (!currentPack || currentPack.region !== "az") {
        insetWrap.classList.remove("show");
        if (insetRect) { insetRect.remove(); insetRect = null; }
        return;
      }

      insetWrap.classList.add("show");

      afterNextPaint(() => {
        if (!insetMap) {
          ensureInsetReady();
          insetPrimed = false;
        }

        if (!insetLayer && insetMap && lastCleanedGeoJSON) {
          insetLayer = L.geoJSON(lastCleanedGeoJSON, { style: styleFill }).addTo(insetMap);
        }

        invalidateInsetSizeHard();

        afterNextPaint(() => {
          invalidateInsetSizeHard();

          const runZoom = () => {
            const ilha = keyToIsland.get(currentTargetKey);
            const b =
              (ilha && islandToBounds.get(ilha)) ? islandToBounds.get(ilha)
              : keyToBounds.get(currentTargetKey);

            if (b && b.isValid && b.isValid()) {
              const usedB = safeZoomToBounds(
                insetMap,
                b,
                { padding: [10, 10], animate: false, maxZoom: 12 },
                0.25
              );

              if (insetRect) insetRect.remove();
              if (usedB) insetRect = L.rectangle(usedB, { color: "#000", weight: 2, fillOpacity: 0 }).addTo(map);
            }
            insetPrimed = true;
          };

          runZoom();
          setTimeout(() => { invalidateInsetSizeHard(); runZoom(); }, 120);
          setTimeout(() => { invalidateInsetSizeHard(); runZoom(); }, 320);

          if (!insetPrimed) {
            setTimeout(() => {
              invalidateInsetSizeHard();
              runZoom();
            }, 60);
          }
        });
      });
    }

    function updateDropdownForInput() {
      if (playPackLevel !== 4) { hideDropdown(); return; }
      if (!playActive || awaitingTap || transitioning) { hideDropdown(); return; }

      const q = normalize(answerInput.value);
      if (!q) { hideDropdown(); return; }

      // já está ordenado alfabeticamente: filtrar preserva ordem
      const matches = [];
      for (const e of playPoolEntries) {
        if (e.norm.startsWith(q)) matches.push(e);
        if (matches.length >= 3) break;
      }

      if (matches.length === 0) { hideDropdown(); return; }

      answerDropdown.innerHTML = "";
      for (const m of matches) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "sugBtn";
        b.textContent = m.name;

        b.addEventListener("click", (ev) => {
          ev.stopPropagation();
          if (Date.now() < suppressChoiceUntil) return;
          if (!playActive || awaitingTap || transitioning) return;

          answerInput.value = m.name;
          hideDropdown();
          submitTextAnswer(m.name);
        });

        answerDropdown.appendChild(b);
      }
      answerDropdown.classList.add("show");
    }

    async function nextRound() {
      stopTimer();
      awaitingTap = false;
      hintUsedThisRound = false;
      inputBlockedUntil = Date.now() + 220;

      const pack = pickPackForRound();
      await ensurePackLoaded(pack);

      currentTargetKey = pickNewTargetKey();

      // modo UI por nível
      const textMode = (playPackLevel === 4);
      setAnswerModeText(textMode);

      if (textMode) {
        clearTextAnswerUI();
        lockTextAnswer(false);
        hideDropdown();
      } else {
        prepareChoicesForRound();
        renderChoices();
        lockChoices(false);
      }

      renderHUD();

      refreshStyles();
      updateAzoresInsetForCurrentTarget();

      timeLine.textContent = String(PLAY.TIME_LIMIT_SEC);
      startTimer();

      if (textMode) {
        afterNextPaint(() => {
          try { answerInput.focus(); } catch {}
          updateDropdownForInput();
        });
      }
    }

    function endSessionOverlay() {
      stopTimer();
      playActive = false;
      awaitingTap = false;
      inputBlockedUntil = Date.now() + 250;

      finalCorrect.textContent = `Corretas: ${sessionCorrect}/${QUESTIONS_PER_SESSION}`;
      finalXP.textContent = `XP ganho: ${sessionXP}`;
      finalOverlay.classList.add("show");
    }

    function submitAnswerChoice(chosenKey) {
      if (!playActive || awaitingTap || transitioning) return;
      if (Date.now() < inputBlockedUntil) return;

      stopTimer();
      const elapsed = (Date.now() - roundStartedAt) / 1000;

      sessionIndex++;

      if (chosenKey === currentTargetKey) {
        sessionCorrect++;
        const xp = computeXPForCorrect(elapsed, playPackLevel, hintUsedThisRound);
        sessionXP += xp;
      } else {
        sessionWrong++;
      }

      awaitingTap = true;
      inputBlockedUntil = Date.now() + 250;

      revealCorrectAndWrong(chosenKey);
      lockChoices(true);
      renderHUD();
    }

    function submitTextAnswer(text) {
      if (!playActive || awaitingTap || transitioning) return;
      if (Date.now() < inputBlockedUntil) return;
      if (Date.now() < suppressChoiceUntil) return;

      const typed = normalize(text);
      if (!typed) return;

      stopTimer();
      const elapsed = (Date.now() - roundStartedAt) / 1000;

      sessionIndex++;

      const correctName = keyToOfficial.get(currentTargetKey) || "";
      const isCorrect = (typed === normalize(correctName));

      if (isCorrect) {
        sessionCorrect++;
        const xp = computeXPForCorrect(elapsed, playPackLevel, hintUsedThisRound);
        sessionXP += xp;
      } else {
        sessionWrong++;
      }

      awaitingTap = true;
      inputBlockedUntil = Date.now() + 250;

      hideDropdown();
      lockTextAnswer(true);

      answerInput.classList.remove("correct", "wrong");
      answerInput.classList.add(isCorrect ? "correct" : "wrong");

      textAnswerFeedback.textContent = isCorrect
        ? "Correto!"
        : (correctName ? `Errado. Era: ${correctName}` : "Errado.");

      renderHUD();
    }

    function useHint() {
      if (!playActive || awaitingTap || hintUsedThisRound || transitioning) return;
      if (Date.now() < inputBlockedUntil) return;

      hintUsedThisRound = true;

      if (playPackLevel === 4) {
        const correctName = keyToOfficial.get(currentTargetKey) || "";
        const seed = correctName.slice(0, Math.min(3, correctName.length));
        answerInput.value = seed;
        answerInput.classList.remove("correct", "wrong");
        textAnswerFeedback.textContent = "";
        try {
          answerInput.focus();
          answerInput.setSelectionRange(answerInput.value.length, answerInput.value.length);
        } catch {}
        updateDropdownForInput();
        renderHUD();
        return;
      }

      // modo escolhas (níveis 1-3)
      const wrong = currentChoicesKeys.filter(k => k !== currentTargetKey);
      const removeCount = Math.min(2, Math.max(0, wrong.length - 1));
      const toHide = sampleDistinct(wrong, removeCount);

      const btns = Array.from(choicesEl.querySelectorAll("button.choiceBtn"));
      for (const b of btns) {
        const k = b.dataset.key || "";
        if (toHide.includes(k)) {
          b.classList.add("hidden");
          b.disabled = true;
        }
      }
      renderHUD();
    }

    async function goNextIfReady() {
      if (transitioning) return;
      if (!awaitingTap) return;
      if (Date.now() < inputBlockedUntil) return;

      if (sessionIndex >= QUESTIONS_PER_SESSION) {
        endSessionOverlay();
        return;
      }

      transitioning = true;

      // airbag para não “cair” na ronda seguinte (opções/input/sugestões)
      suppressChoiceUntil = Date.now() + 450;

      try {
        await nextRound();
      } finally {
        transitioning = false;
      }
    }

    document.addEventListener("pointerup", async (e) => {
      if (!screenGame.classList.contains("active")) return;
      if (e.target.closest("#btnExit, #btnHint")) return;

      // enquanto ainda NÃO respondeste no nível 4, tocar no input/dropdown não avança
      if (!awaitingTap && e.target.closest("#answerInput, #answerDropdown")) return;

      if (finalOverlay.classList.contains("show")) {
        backToMenu();
        return;
      }

      await goNextIfReady();
    }, true);

    finalOverlay.addEventListener("click", (e) => {
      e.stopPropagation();
      backToMenu();
    });

    // Listeners do nível 4 (texto)
    answerInput.addEventListener("input", (e) => {
      if (Date.now() < suppressChoiceUntil) return;
      if (playPackLevel !== 4) return;
      if (!playActive || awaitingTap || transitioning) return;
      answerInput.classList.remove("correct", "wrong");
      textAnswerFeedback.textContent = "";
      updateDropdownForInput();
    });

    answerInput.addEventListener("keydown", (e) => {
      if (playPackLevel !== 4) return;
      if (e.key !== "Enter") return;

      e.preventDefault();
      e.stopPropagation();

      if (Date.now() < suppressChoiceUntil) return;
      if (!playActive || awaitingTap || transitioning) return;

      const val = (answerInput.value || "").trim();
      if (!val) return;
      submitTextAnswer(val);
    });

    /* =========================
       SESSION CONTROL
       ========================= */
    function resetSession() {
      stopTimer();
      awaitingTap = false;
      transitioning = false;
      inputBlockedUntil = Date.now() + 200;
      hintUsedThisRound = false;

      suppressChoiceUntil = 0;

      sessionIndex = 0;
      sessionCorrect = 0;
      sessionWrong = 0;
      sessionXP = 0;

      playActive = false;
      currentTargetKey = "";
      currentChoicesKeys = [];

      finalOverlay.classList.remove("show");

      timeLine.textContent = String(PLAY.TIME_LIMIT_SEC);
      sessionLine.textContent = `1/${QUESTIONS_PER_SESSION}`;
      choicesEl.innerHTML = "";

      clearTextAnswerUI();
      lockTextAnswer(true);

      insetWrap.classList.remove("show");
      if (insetRect) { insetRect.remove(); insetRect = null; }
      insetPrimed = false;
    }

    async function startGame() {
      document.body.classList.add("playing");
      showScreen(screenLoading);
      setLoading("A iniciar…", 10);

      try {
        const opts = loadOptions();
        selectedPacks = getSelectedPacksFromOptions(opts);
        if (selectedPacks.length === 0) selectedPacks = getSelectedPacksFromOptions(defaultOptions());

        resetSession();
        setLoading("A preparar ecrã…", 25);

        showScreen(screenGame);
        await new Promise(resolve => afterNextPaint(resolve));

        ensureMapReady();
        setMapInteractive(false);
        invalidateMapSizeHard();

        playActive = true;
        setLoading("Concluído", 100);

        transitioning = true;
        await nextRound();
        transitioning = false;
      } catch (e) {
        console.error(e);
        showScreen(screenMenu);
        document.body.classList.remove("playing");
        alert("Erro a iniciar o jogo. Vê a consola para detalhes.");
      }
    }

    function backToMenu() {
      resetSession();
      clearLayer();
      currentPack = null;

      document.body.classList.remove("playing");
      showScreen(screenMenu);

      setMapInteractive(true);
    }

    btnExit.addEventListener("click", (e) => {
      e.stopPropagation();
      backToMenu();
    });

    btnHint.addEventListener("click", (e) => {
      e.stopPropagation();
      useHint();
    });

    (function init() {
      showScreen(screenMenu);
    })();
  </script>
</body>
</html>


